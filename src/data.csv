Nr,Opcja,Poprawna
1,Instrukcja SELECT służy do: - (0)
,sprowadzania rekordów z bazy danych,+
,wstawiania rekordów do bazy danych,
,usuwania rekordów z bazy danych,
,aktualizacji rekordów w bazie danych,
2,Instrukcja INSERT służy do: - (0)
,sprowadzania rekordów z bazy danych,
,wstawiania rekordów do bazy danych,+
,usuwania rekordów z bazy danych,
,aktualizacji rekordów w bazie danych,
3,Instrukcja DELETE służy do: - (0)
,sprowadzania rekordów z bazy danych,
,wstawiania rekordów do bazy danych,
,usuwania rekordów z bazy danych,+
,aktualizacji rekordów w bazie danych,
4,Instrukcja UPDATE służy do: - (0)
,sprowadzania rekordów z bazy danych,
,wstawiania rekordów do bazy danych,
,usuwania rekordów z bazy danych,
,aktualizacji rekordów w bazie danych,+
5,INDEKS w bazie danych przyśpiesza: - (2)
,wyszukiwania rekordów w bazie danych,+
,wstawiania rekordów do bazy danych,
,usuwania rekordów z bazy danych,
,autoryzację użytkowników w bazie danych,
6,Instrukcja COMMIT służy do: - (1)
,wycofywania zmian w bazie danych,
,wstawiania rekordów do bazy danych,
,zatwierdzania zmian w bazie danych,+
,aktualizacji rekordów w bazie danych,
7,Instrukcja ROLLBACK służy do: - (0)
,wycofywania zmian w bazie danych,+
,zatwierdzania zmian w bazie danych,
,usuwania rekordów z bazy danych,
,aktualizacji rekordów w bazie danych,
8,Instrukcja GRANT służy do: - (0)
,przyznawania uprawnień w bazie danych,+
,zatwierdzania zmian w bazie danych,
,odbierania uprawnień w bazie danych,
,aktualizacji rekordów w bazie danych,
9,Instrukcja REVOKE służy do: - (0)
,przyznawania uprawnień w bazie danych,
,zatwierdzania zmian w bazie danych,
,odbierania uprawnień w bazie danych,+
,wycofywania zmian w bazie danych,
10,Instrukcja ALTER TABLE służy do: - (3)
,tworzenia tabeli,
,usuwania tabeli,
,zmiany schematu tabeli,+
,aktualizacji indeksów założonych na tabeli,
11,Jaka jest wartość wyrażenia Null=Null: - (2)
,jest nieokreślone,
,True,
,False,
,Null,+
12,Jaka jest wartość wyrażenia True OR Null: - (0)
,jest nieokreślone,
,True,+
,False,
,Null,
13,Jaka jest wartość wyrażenia False OR Null: - (0)
,jest nieokreślone,
,True,
,False,
,Null,+
14,Jaka jest wartość wyrażenia False AND Null: - (0)
,jest nieokreślone,
,True,
,False,+
,Null,
15,Jaka jest wartość wyrażenia True AND Null: - (0)
,jest nieokreślone,
,True,
,False,
,Null,+
16,Jaka jest wartość wyrażenia NOT Null: - (0)
,jest nieokreślone,
,True,
,False,
,Null,+
17,Co będzie wynikiem realizacji instrukcji SELECT * FROM Emp WHERE EmpNo=EmpNo OR EmpNo=NULL - (5)
,relacja Emp,+
,relacja pusta,
,instrukcja jest niepoprawna,
18,Co będzie wynikiem realizacji instrukcji SELECT * FROM Emp WHERE EmpNo=EmpNo AND NULL=EmpNo - (0)
,relacja Emp,
,relacja pusta,+
,instrukcja jest niepoprawna,
19,Relacja R ma atrybut a. Jaka liczba może być wynikiem wykonania instrukcji SELECT Count(*) FROM R WHERE a=a - (13)
,0,+
,1,+
,zawsze tyle jaka jest liczebność relacji R.,
,dowolna liczba całkowita,
20,"Relacja R ma atrybut a. Jaka liczba może być wynikiem wykonania instrukcji SELECT Count(*) FROM R WHERE a<a <zzzz="""" src=""question.png"" height=""16"" width=""16"" onclick=""window.open('?comment=660','komentarze','width=560,height=360')""> - (4)"
,zawsze 0,+
,1dowolna liczba całkowita,
,tyle jaka jest liczebność relacji R.,
21,Encji odpowiada w relacyjnej bazie danych: - (0)
,wiersz w tabeli,
,kolumna w tabeli,
,tabela,+
,klucz obcy,
22,Związkowi jednoznacznemu odpowiada w relacyjnej bazie danych: - (2)
,kolumna w tabeli,
,klucz obcy,+
,indeks w tabeli,
,wartość NULL,
23,Związkowi wieloznacznemu odpowiada w relacyjnej bazie danych: - (0)
,klucz obcy,
,tabela,+
,kolumna w tabeli,
,wiersz w tabeli,
24,Atrybutowi w relacyjnej bazie danych odpowiada: - (0)
,kolumna w tabeli,+
,wiersz w tabeli,
,tabela,
,indeks w tabeli,
25,Jednoznacznemu identyfikatorowi odpowiada w relacyjnej bazie danych: - (0)
,kolumna w tabeli,
,indeks w tabeli,
,klucz obcy,
,klucz główny,+
26,Spójność referencyjna dotyczy faktu: - (0)
,wartością klucza obcego może być null lub wartość odpowiadającego mu klucza głównego,+
,wartości w kolumnie nie powtarzają się,
,wartości w kolumnie nie mogą zależeć ani od części klucza ani nawet przechodnio od klucza,
,w każdej tabeli powinien istnieć dokładnie jeden klucz,
27,III postać normalna dotyczy faktu: - (0)
,wartością klucza obcego może być null lub wartość odpowiadającego mu klucza głównego,
,wartości w kolumnie nie powtarzają się,
,wartości w kolumnie niekluczowej nie mogą zależeć ani od części klucza ani nawet przechodnio od klucza,+
,w każdej tabeli powinien istnieć dokładnie jeden klucz,
28,Które ze sformułowań są prawdziwe w modelu relacyjnym: - (0)
,wartości w kolumnie są przechowywane w kolejności posortowanej,
,wiersze nie powtarzają się,+
,kolejność kolumn jest nieistotna,+
,wartości w kolumnie nie powtarzają się,
29,Które ze sformułowań są prawdziwe w modelu relacyjnym: - (0)
,wiersze nie mają tożsamości obiektowej,+
,związek jednoznaczny reprezentuje się przy pomocy klucza obcego,+
,związek wieloznaczny reprezentuje się przy pomocy klucza obcego,
,klucze obce muszą być typu całkowitego,
30,Które ze sformułowań są prawdziwe w modelu relacyjnym: - (7)
,tabela jest konkretną reprezentacją relacji,+
,dla klucza jednoznacznego jest automatycznie zakładany indeks,+
,dla klucza obcego jest automatycznie zakładany indeks,
,dla klucza głównego jest automatycznie zakładany indeks jednoznaczny,+
31,Które ze sformułowań są prawdziwe w modelu relacyjnym: - (4)
,klucz obcy nie może być częścią klucza główego,
,klucz główny nie może być częścią klucza obcego,+
,wartości klucza głównego nie mogą się powtarzać,+
,wartości klucza obcego nie mogą się powtarzać,
32,Zależność złączeniowa jest uogólnieniem zależności wielowartościowej w następującym sensie: - (0)
,"dotyczy rozbicia tabeli na dokładnie dwie tabele,",
,"dotyczy rozbicia tabeli na dokładnie trzy tabele,",
,"dotyczy rozbicia tabeli na więcej niż dwie tabele,",+
,"dotyczy rozbicia tabeli na co najmniej dwie tabele,",
33,Postać normalna Boyce'a-Codda dotyczy faktu: - (1)
,wartością klucza obcego może być null lub wartość odpowiadającego mu klucza głównego,
,"każda nietrywialna zależność funkcyjna jest zależnością od nadklucza,",+
,wartości w kolumnie niekluczowej nie mogą zależeć ani od części klucza ani nawet przechodnio od klucza,
,w każdej tabeli powinien istnieć dokładnie jeden klucz,
34,Które z poniższych stwierdzeń są prawdziwe: - (0)
,"jedyną poprawną, nietrywialną zależnością funkcyjną jest zależność do klucza,",+
,"należy starać się użyć najmniejszej możliwej liczby tabel,",
,"w tabeli nie powinno być żadnych niekontrolowanych redundancji,",+
,należy wszystkie związki jednoznaczne zastąpić związkami jednojednoznacznymi.,
35,Które z poniższych stwierdzeń są prawdziwe: - (0)
,"każdy fakt przechowywany w bazie danych powinien być w niej wyrażany tylko na jeden sposób,",+
,"należy starać się użyć najmniejszej możliwej liczby tabel,",
,"należy skonsultować z użytkownikiem poprawność skonstruowanego modelu danych,",+
,należy spytać się użytkownika czy schemat tabel jest w III postaci normalnej.,
36,"Dany jest schemat relacyjny R={Miasto, Ulica, Kod}, F = {Miasto,Ulica->Kod; Kod->Miasto}. W której postaci normalnej jest ten schemat: - (6)"
,I postać normalna;,+
,"II postać normalna,",+
,"III postać normalna,",+
,postać normalna Boyce'a-Codda.,
37,"Dany jest schemat relacyjny R={Miasto, Ulica, Kod, Poczta}, F = {Miasto,Ulica->Kod; Kod->Miasto; Kod->Poczta}. W której postaci normalnej jest ten schemat: - (4)"
,I postać normalna;,+
,"II postać normalna,",+
,"III postać normalna,",
,postać normalna Boyce'a-Codda.,
38,"Dany jest schemat relacyjny R={Miasto, Ulica, Kod, Poczta}, F = {Miasto,Ulica->Kod; Kod->Poczta}. W której postaci normalnej jest ten schemat: - (6)"
,I postać normalna;,+
,"II postać normalna,",+
,"III postać normalna,",
,postać normalna Boyce'a-Codda.,
39,"Dany jest schemat relacyjny R={Miasto, Ulica, Kod}, F = {Miasto,Ulica->Kod}. W której postaci normalnej jest ten schemat: - (2)"
,I postać normalna;,+
,"II postać normalna,",+
,"III postać normalna,",+
,postać normalna Boyce'a-Codda.,+
40,"Dany jest schemat relacyjny R={Ulica, Kod, Sklep}, F = {Ulica->Kod; Sklep->Ulica}. W której postaci normalnej jest ten schemat: - (0)"
,I postać normalna;,+
,"II postać normalna,",+
,"III postać normalna,",
,postać normalna Boyce'a-Codda.,
41,"Dany jest schemat relacyjny R={Ulica, Kod, Sklep}, F = {Ulica->Kod; Ulica, Numer ->Sklep}. W której postaci normalnej jest ten schemat: - (3)"
,I postać normalna;,+
,"II postać normalna,",
,"III postać normalna,",
,postać normalna Boyce'a-Codda.,
42,"Dany jest schemat relacyjny R={Student,Adres,Akademik}, F = {Student->Adres; Akademik->Adres; Student->Akademik}. W której postaci normalnej jest ten schemat: - (0)"
,I postać normalna;,+
,"II postać normalna,",+
,"III postać normalna,",
,postać normalna Boyce'a-Codda.,
43,"Dany jest schemat relacyjny R={Student,Uczelnia,Adres,Klub}, F = {Student->Uczelnia; Klub->Adres}. W której postaci normalnej jest ten schemat: - (1)"
,I postać normalna;,+
,"II postać normalna,",
,"III postać normalna,",
,postać normalna Boyce'a-Codda.,
44,"Dany jest schemat relacyjny R={Student,Uczelnia,Adres,Klub}, F = {Student->Uczelnia; Klub->Adres;Uczelnia->Adres}. W której postaci normalnej jest ten schemat: - (0)"
,I postać normalna;,+
,"II postać normalna,",
,"III postać normalna,",
,postać normalna Boyce'a-Codda.,
45,"Dany jest schemat relacyjny R={Student,Uczelnia,Adres,Akademik}, F = {Student, Uczelnia->Klub; Klub->Adres}. W której postaci normalnej jest ten schemat: - (2)"
,I postać normalna;,+
,"II postać normalna,",+
,"III postać normalna,",
,postać normalna Boyce'a-Codda.,
46,Studenci mają pomysły. Każdy pomysł dotyczy pewnej rzeczy. Każdy pomysł przychodzi do głowy dokładnie jednemu studentowi. Student może się podzielić pomysłem z kolegami-studentami. Który ze schematów jest najodpowiedniejszy z punktu widzenia zasad projektowania baz danych: - (0)
,"Studenci(id_studenta, imię, nazwisko, adres, id_pomysłu)
Pomysły(id_pomysłu, rzecz, opis)
Koledzy(id_kolegi, imię, nazwisko, id_studenta, id_pomysłu)",
,"Studenci(id_studenta, imię, nazwisko, adres, id_kolegi)
Pomysły(id_pomysłu, rzecz, opis, id_studenta)
Koledzy(id_kolegi, imię, nazwisko, id_studenta, id_pomysłu)",
,"Studenci(id_studenta, imię, nazwisko, adres)
Pomysły(id_pomysłu, rzecz, opis, id_studenta)
Koledzy(id_pomysłu, id_kolegi)",+
,"Studenci(id_studenta, imię, nazwisko, adres)
Pomysły(id_pomysłu, rzecz, opis, id_studenta, id_kolegi)",
47,"Studenci lubią się, są sobie obojętni lub nie znoszą się (nie ma innej możliwości). Który ze schematów jest najodpowiedniejszy z punktu widzenia zasad projektowania baz danych : - (2)"
,"Studenci(id_studenta, imię, nazwisko)
Koledzy(id_kolegi, imię, nazwisko, id_studenta, id_stosunku_do)
Stosunek(id_stosunku_do, stosunek_do)",
,"Studenci(id_studenta, imię, nazwisko)
Koledzy(id_kolegi, imię, nazwisko, id_studenta, stosunek_do)",
,"Studenci(id_studenta, imię, nazwisko)
Lubi(id_studenta, id_kolegi)
Nie_znosi(id_studenta, id_kolegi)
Obojętny(id_studenta, id_kolegi)",
,"Studenci(id_studenta, imię, nazwisko)
Lubi(id_studenta, id_kolegi)
Nie_znosi(id_studenta, id_kolegi)",+
48,W domach mieszkają zwierzęta domowe. Niektóre zwierzęta zjadają się wzajemnie. Domy mogą być położone obok siebie. Jaki schemat zgodny z zasadami projektowania schematów baz danych jest najodpowiedniejszy dla organizacji zajmującej się ochroną zwierząt: - (0)
,"Domy(id_domu, adres, id_zwierzę)
Zwierzęta(id_zwierzę, rodzaj, id_zw_zjadane)",
,"Domy(id_domu, adres) 
Zwierzęta(id_zwierzę, id_rodzaju, id_domu) 
Rodzaje(id_rodzaju, rodzaj)
Obok_siebie(id_domu1, id_domu2) 
Zjada(id_rodz_je, id_rodz_zjadane)",+
,"Domy(id_domu, adres)
Zwierzęta(id_zwierzę, id_rodzaju, id_domu) 
Rodzaje(id_rodzaju, rodzaj)
Sąsiedzi(id_zwierzę1, id_zwierzę2)
Zjada(id_rodz_je, id_rodz_zjadane)",
,"Domy(id_domu, adres, id_zwierzę, rodzaj)
Obok_siebie(id_domu1, id_domu2)
Zjada(id_zw_je, id_zw_zjadane)",
49,W filmach grają aktorzy. Każdy film ma dokładnie jednego reżysera i jednego lub więcej scenarzystę. Który z poniższych schematów jest najodpowiedniejszy z punktu widzenia zasad projektowania baz danych: - (5)
,"Filmy(id_filmu, tytuł, reżyser, gaża_reżysera)
Aktorzy(id_aktora, nazwisko,rola, id_filmu, gaża)
Scenarzyści(id_scenarzysty, nazwisko, id_filmu, gaża)",+
,"Filmy(id_filmu, tytuł, id_reżysera, gaża_reżysera)
Osoby(id_osoby, nazwisko)
Aktorzy(id_aktora, id_filmu, rola, gaża)
Scenarzyści(id_scenarzysty, id_filmu, gaża)",
,"Filmy(id_filmu, tytuł, id_reżysera)
Osoby(id_osoby, nazwisko)
Zespół(id_osoby, id_filmu, rola, gaża)",
,"Zespół(tytuł_filmu, nazwisko_osoby, rola, gaża)",
50,"Politycy należą do partii politycznych (czasami je zmieniają, czasami dokonują ich podziału). Partie polityczne, przed wyborami, tworzą koalicje wyborcze. Który z poniższych schematów jest najodpowiedniejszy z punktu widzenia zasad projektowania baz danych: - (0)"
,"Politycy(id_polityka, imię, nazwisko)
Partie(id_partii, nazwa, od, do)
Koalicje(id_koalicji, data_wyborów)
Członkowie(id_partii, id_osoby, od, do)
W_koalicji(id_partii, id_koalicji, od, do)",+
,"Osoby(id_osoby, imię, nazwisko, id_partii)
Partie(id_partii, nazwa, id_koalicji)
Politycy(id_osoby, id_partii, od, do)
Koalicje(id_koalicji, data_wyborów)",
,"Partie(id_partii, nazwa, koalicja, polityk, od, do)",
,"Politycy(id_polityka, imię, nazwisko, id_partii, od, do)
Partie(id_partii, nazwa, od, do)
Koalicje(id_koalicji, data_wyborów)
W_koalicji(id_partii, id_koalicji, od, do)",
51,"Studenci planują, czym chcieliby się zajmować w swojej przyszłej pracy zawodowej i jakie stanowiska chcieliby pełnić. Który z poniższych schematów jest najodpowiedniejszy z punktu widzenia zasad projektowania baz danych: - (1)"
,"Studenci(id_studenta, imię, nazwisko)
Zajęcia(id_zajęcia, nazwa)
Stanowiska(id_stanowiska, nazwa)
Kto_co(id_studenta, id_stanowiska, id_zajęcia)",
,"Studenci(id_studenta, imię, nazwisko, rok)
Zajęcia(id_zajęcia, nazwa)
Stanowiska(id_stanowiska, nazwa)
Jakie_zajęcie(id_studenta, id_zajęcia)
Jakie_stanowisko(id_studenta, id_stanowiska)",+
,"Studenci(imię, nazwisko, rok, zajęcie, stanowisko)",
,"Studenci(id_studenta, imię, nazwisko,rok)
Kto_co(id_studenta, stanowisko, zajęcie)",
52,"W PJWSTK ma powstać baza danych zbierająca informacje o umiejętnościach przydatnych w pracy zawodowej, o przedmiotach, które uczą tych umiejętności oraz o książkach, w których umiejętności są opisane. Który z poniższych schematów jest najodpowiedniejszy z punktu widzenia zasad projektowania baz danych: - (2)"
,"Umiejętności(umiejętność, przedmiot, książka)",
,"Przedmioty(id_przedmiotu, nazwa, semestr)
Książki(ISBN, tytuł, autorzy)
Umiejętności(id_umiejętności, id_przedmiotu, nazwa, opis, ISBN, od_strony, do_strony)",
,"Przedmioty(id_przedmiotu, nazwa, semestr)
Książki(ISBN, tytuł, sygnatura)
Umiejętności(id_umiejętności, nazwa, opis)
Gdzie(id_umiejętności, ISBN, od_strony, do_strony)
Na(id_umiejętności, id_przedmiotu)",+
,"Przedmioty(id_przedmiotu, nazwa, semestr)
Egzemplarze_książek(sygnatura, tytuł, autorzy, nr_półki)
Umiejętności(id_umiejętności, nazwa, opis)
Gdzie(id_umiejętności, sygnatura, od_strony, do_strony)",
53,"W PJWSTK powstaje baza danych z informacjami, jakie oprogramowanie jest zainstalowane w poszczególnych salach - z myślą o prowadzeniu w nich ćwiczeń z odpowiednich przedmiotów. Który z poniższych schematów jest najodpowiedniejszy z punktu widzenia zasad projektowania baz danych: - (5)"
,"Sale(numer_sali, nazwa_programu, wersja, ile_instalacji)
Programy(nazwa_programu, wersja, nazwa_przedmiotu)",
,"Programy(id_programu, firma, nazwa, wersja)
Przedmioty(id_przedmiotu, nazwa)
Sale_programy(nr_sali, id_programu, ile_instalacji)
Przedmioty_programy(id_przedmiotu, id_programu)",+
,"Programy(id_programu, firma, nazwa, wersja, nazwa_przedmiotu)
Sale_programy(nr_sali, id_programu, wersja, ile_instalacji)",
,"Sale(id_sali, numer, ile_komputerów)
Programy(id_programu, firma, nazwa, wersja)
Przedmioty(id_przedmiotu, nazwa)
Sale_programy(id_sali, id_programu, wersja, ile_instalacji)
Przedmioty_programy(id_przedmiotu, id_programu, wersja)",
54,"Który ze schematów bazy danych dla biblioteki jest najodpowiedniejszy z punktu widzenia zasad projektowania baz danych. Baza powinna przechowywać informacje o klientach, książkach i wypożyczeniach (wielkie litery oznaczają klucz główny): - (15)"
,"Klient(ID_KLIENTA, imię, nazwisko, adres)
Książka(ID_KSIąŻKI, tytuł, autor)
Wypożyczenie(ID_KLIENTA, id_książki, data_wypożyczenia, data_zwrotu)",
,"Klient(ID_KLIENTA, imię, nazwisko, adres)
Książka(ID_KSIąŻKI, tytuł, autor)
Wypożyczenie(ID_KLIENTA, ID_KSIąŻKI, data_wypożyczenia, data_zwrotu)",
,"Klient(ID_KLIENTA, imię, nazwisko, adres)
Książka(ID_KSIąŻKI, tytuł, autor)
Wypożyczenie(ID_KLIENTA, ID_KSIąŻKI, DATA_WYPOŻYCZENIA, data_zwrotu)",+
,"Klient(ID_KLIENTA, imię, nazwisko, adres)
Książka(ID_KSIąŻKI, tytuł, autor)
Wypożyczenie(ID_KLIENTA, ID_KSIąŻKI, DATA_WYPOŻYCZENIA, DATA_ZWROTU)",
55,Potrzebna jest baza danych do ewidencji studentów i ich ocen. Który ze schematów bazy danych jest najodpowiedniejszy z punktu widzenia zasad projektowania baz danych: - (3)
,"Student(id_studenta, imię, nazwisko)
Ocena(id_oceny, ocena, data_wystawienia, nazwa_przedmiotu)",
,"Student(id_studenta, imię, nazwisko)
Ocena(id_oceny, ocena, data_wystawienia, id_przedmiotu, id_studenta)
Przedmiot(id_przedmiotu, nazwa)",+
,"Student(id_studenta, imię, nazwisko, id_oceny)
Ocena(id_oceny, ocena, data_wystawienia, id_przedmiotu)
Przedmiot(id_przedmiotu, nazwa)",
,"Student(id_studenta, imię, nazwisko, ocena)
Przedmiot(id_przedmiotu, nazwa, id_studenta)",
56,"Wiedząc, że tabela TEST ma następującą strukturę: 

 id number(5)
 pole1 varchar2(30)
 pole2 varchar2(30)

Zaznacz, które z poniższych wyrażeń są poprawnymi składniowo instrukcjami języka SQL: - (3)"
,"INSERT INTO TEST(ID,POLE1,POLE2) SELECT EMPNO,ENAME,JOB FROM EMP;",+
,"INSERT INTO TEST(ID,POLE1,POLE2) VALUES(SELECT EMPNO,ENAME,JOB FROM EMP);",
,"INSERT INTO TEST VALUES(12345, 'KOWALSKI');",
57,Chcesz usunąć z bazy wyzwalacz TRG_TEST. Które polecenie zastosujesz? - (0)
,DELETE FROM USER_TRIGGERS WHERE TRIGGER_NAME = 'TRG_TEST';,
,DELETE TRIGGER TRG_TEST;,
,REMOVE TRIGGER TRG_TEST;,
,DROP TRIGGER TRG_TEST;,+
58,"Dana jest tabela Osoby(Imie, Nazwisko, Zarobki). Które z następujących instrukcji są składniowo poprawnymi instrukcjami SQL w Oracle: - (13)"
,UPDATE Osoby WHERE Nazwisko='KOWALSKI';,
,UPDATE Osoby SET Nazwisko=USER;,+
,"SELECT Osoby.Nazwisko, Osoby.Imie, Osoby.Zarobki WHERE Osoby.Zarobki >1000;",
,"SELECT Osoby.Nazwisko, Osoby.Imie, Osoby.Zarobki ORDER BY Osoby.Zarobki;",
,"SELECT Osoby.Nazwisko, Osoby.Imie, Osoby.Zarobki HAVING Osoby.Zarobki>1000;",
,"SELECT Osoby.Nazwisko, Osoby.Imie, Osoby.Zarobki FROM Osoby HAVING Osoby.Zarobki>1000;",
,"SELECT Osoby.Nazwisko, Osoby.Imie, Osoby.Zarobki FROM Osoby GROUP BY Osoby.Nazwisko;",
,"INSERT INTO Osoby VALUES ('Jan', 'Kowalski', 2000) WHERE USER = 'KOWALSKI';",
,INSERT INTO Osoby SELECT * FROM Osoby WHERE USER = 'KOWALSKI';,+
,INSERT INTO Osoby SELECT * FROM Osoby WHERE Nazwisko = 'KOWALSKI';,+
,"INSERT INTO Osoby SELECT Nazwisko, Imie FROM Osoby WHERE USER = 'KOWALSKI';",
,DELETE FROM Osoby WHERE USER='KOWALSKI';,+
,DELETE FROM Osoby WHERE 'JANKOWSKI'='KOWALSKI';,+
,DELETE FROM Osoby WHENEVER Osoby.Zarobki<1000;,
,"SELECT Osoby.Nazwisko, Osoby.Imie, Osoby.Zarobki FROM Osoby WHERE Osoby.Zarobki >1000",+
59,"Dane są dwie tabele Osoby(Imie, Nazwisko, Zarobki, Id_działu) oraz Działy(Id_działu, Nazwa). Które z następujących instrukcji są poprawnymi instrukcjami SQL w Oracle: - (1)"
,"SELECT Osoby.Nazwisko, Osoby.Imie, Osoby.Id_działu WHERE Działy.Nazwa='PRAWNY';",
,"INSERT INTO Osoby(Imie, Nazwisko,Zarobki) VALUES ('Jan', 'Kowalski', 2000);",+
,DELETE FROM Osoby WHERE Id_działu=(SELECT Id_działu FROM Działy WHERE Nazwa='BUFET');,+
,UPDATE Osoby DELETE Nazwisko=USER;,
60,"Dane są dwie tabele Osoby(Imie, Nazwisko, Zarobki, Id_działu) oraz Działy(Id_działu, Nazwa). Które z następujących instrukcji są poprawnymi instrukcjami SQL w Oracle: - (10)"
,"SELECT Osoby.Nazwisko, Działy.Nazwa FROM Osoby, Działy WHERE Osoby.Id_działu=Działy.Id_działu GROUP BY Osoby.Nazwisko;",
,"INSERT INTO Osoby VALUES ('Jan', 'Kowalski', 2000) WHERE Osoby.Id_działu = 23;",
,"DELETE FROM Osoby, Działy WHERE Osoby.Nazwisko='KOWALSKI' AND Działy.Nazwa='KASA';",
,UPDATE Osoby SET Id_działu=NULL;,+
61,"Dane są dwie tabele Osoby(Imie, Nazwisko, Zarobki, Id_działu) oraz Działy(Id_działu, Nazwa). Które z następujących instrukcji są poprawnymi instrukcjami SQL w Oracle: - (3)"
,"SELECT Osoby.Nazwisko, COUNT(Działy.Nazwa) FROM Osoby, Działy WHERE Osoby.Id_działu=Działy.Id_działu GROUP BY Osoby.Nazwisko;",+
,"INSERT INTO Osoby VALUES ('Jan', 'Kowalski', 2000) WHERE Osoby.Id_działu = 23;",
,"DELETE FROM Osoby, Działy WHERE Osoby.Nazwisko='KOWALSKI' AND Działy.Nazwa='KASA' AND Osoby.Id_działu=Działy.Id_działu;",
,UPDATE Osoby SET Id_działu=NULL WHERE COUNT(*)<5;,
62,"Dane są dwie tabele Osoby(Imie, Nazwisko, Zarobki, Id_działu) oraz Działy(Id_działu, Nazwa). Które z następujących instrukcji są poprawnymi instrukcjami SQL w Oracle: - (2)"
,"SELECT Osoby.Nazwisko, COUNT(Działy.Nazwa) FROM Osoby, Działy WHERE Osoby.Id_działu=Działy.Id_działu GROUP BY Osoby.Nazwisko HAVING COUNT(Id_działu)<2;",
,"INSERT INTO Osoby VALUES ('Jan', 'Kowalski', 2000) WHERE Osoby.Id_działu = 23;",
,"DELETE FROM Osoby, Działy WHERE Osoby.Nazwisko='KOWALSKI' AND Działy.Nazwa='KASA' AND Osoby.Id_działu=Działy.Id_działu;",
,UPDATE Osoby SET Id_działu=NULL WHERE 5>(SELECT COUNT(*) FROM Działy);,+
63,"Dane są dwie tabele Osoby(Imie, Nazwisko, Zarobki, Id_działu) oraz Działy(Id_działu, Nazwa). Które z następujących instrukcji są poprawnymi instrukcjami SQL w Oracle: - (2)"
,"SELECT Osoby.Nazwisko, Działy.Nazwa FROM Osoby, Działy WHERE Osoby.Id_działu=Działy.Id_działu GROUP BY Osoby.Nazwisko HAVING COUNT(Działy.Id_działu)<2;",
,"INSERT INTO Osoby VALUES ('Jan', 'Kowalski', 2000);",
,DELETE FROM Osoby WHERE Osoby.Nazwisko='KOWALSKI' AND Działy.Id_działu=22;,
,UPDATE Osoby SET Id_działu=NULL WHERE 5>(SELECT COUNT(*) FROM Działy);,+
64,"Dana jest tabela Osoby(imie, nazwisko, zarobki). Które z następujących instrukcji są poprawnymi instrukcjami SQL w Oracle: - (0)"
,"SELECT imie, nazwisko, zarobki FROM osoby UNION SELECT imie, nazwisko FROM osoby;",
,SELECT AVG(zarobki) FROM osoby;,+
,"SELECT imie, nazwisko FROM osoby WHERE zarobki = MAX(zarobki);",
,"SELECT imie, nazwisko FROM osoby HAVING zarobki = MAX(zarobki);",
65,"Dana jest tabela Osoby(imie, nazwisko, zarobki, id_dzialu). Które z następujących instrukcji są poprawnymi instrukcjami SQL w Oracle: - (2)"
,"SELECT imie, nazwisko, AVG(zarobki) FROM Osoby GROUP BY id_dzialu;",
,"SELECT id_dzialu, AVG(zarobki) FROM Osoby GROUP BY id_dzialu;",+
,"SELECT id_dzialu, AVG(zarobki) FROM Osoby GROUP BY id_dzialu WHERE AVG(zarobki) > 1000;",
,SELECT AVG(zarobki) from Osoby WHERE zarobki > 1000;,+
66,"Dana jest tabela Osoby(imie, nazwisko, zarobki). Które z następujących instrukcji są poprawnymi instrukcjami SQL w Oracle: - (0)"
,"INSERT INTO Osoby (imie, nazwisko, zarobki) VALUES ('Jan', 'Kowalski', 1000);",+
,"INSERT INTO Osoby VALUES ('Jan', 'Kowalski');",
,DELETE FROM Osoby WHERE Nazwisko LIKE 'Kowalski';,+
,UPDATE Osoby.Nazwisko = 'Kowalski';,
67,Wskazać poprawne zapytanie SQL znajdujące pracowników zarabiających minimalną pensję na ich stanowiskach pracy. - (6)
,"SELECT ename, job, sal FROM emp e WHERE sal = (SELECT MIN(sal)FROM emp WHERE job = e.job);",+
,"SELECT ename, job, sal FROM emp WHERE( sal,job) in (SELECT MIN(sal),job FROM emp GROUP BY job );",+
,"SELECT ename, job, sal FROM emp WHERE sal = (SELECT MIN(sal)FROM emp GROUP BY job );",
,"SELECT ename, job, MIN(sal) FROM emp GROUP BY job;",
,,
68,Wskazać poprawne zapytanie SQL znajdujące dla każdego departamentu ostatnio zatrudnionych pracowników. - (2)
,"SELECT deptno, ename, hiredate FROM emp WHERE (hiredate, deptno) IN (SELECT MAX(hiredate), deptno FROM emp GROUP BY deptno);",+
,"SELECT deptno, ename, hiredate FROM emp e WHERE (hiredate,) = (SELECT MAX(hiredate) FROM emp WHERE deptno=e.deptno GROUP BY deptno);",+
,"SELECT deptno, ename, hiredate FROM emp WHERE hiredate = (SELECT MAX(hiredate) FROM emp GROUP BY deptno);",
,"SELECT deptno, ename, MAX(hiredate) FROM emp GROUP BY deptno;",
69,Wskazać poprawne zapytanie SQL znajdujące pracowników o najniższych zarobkach w ich działach. - (5)
,"SELECT ename, sal, deptno FROM emp WHERE (sal, deptno) IN (SELECT MIN(sal), deptno FROM empGROUP BY deptno);",+
,"SELECT ename, deptno, sal FROM emp e WHERE sal = (SELECT MIN(sal)FROM emp WHERE deptno = e. deptno);",+
,"SELECT ename, sal, deptno FROM emp WHERE sal IN (SELECT MIN(sal)FROM emp GROUP BY deptno)",
,"SELECT ename MIN(sal), deptno FROM emp GROUP BY deptno)",
70,"Wskazać poprawne zapytanie SQL znajdujące pracowników, których zarobki są wyższe od pensji każdego pracownika z departamentu 30. - (2)"
,"SELECT ename, sal, job, deptno FROM emp WHERE sal> ALL (SELECT DISTINCT sal FROM emp WHERE deptno = 30);",+
,"SELECT ename, sal, job, deptno FROM emp WHERE sal> (SELECT Max( sal) FROM emp WHERE deptno = 30);",+
,"SELECT ename, sal, job, deptno FROM emp WHERE sal> ANY (SELECT DISTINCT sal FROM emp WHERE deptno = 30);",
,"SELECT ename, sal, job, deptno FROM emp WHERE sal> (SELECT Min( sal) FROM emp WHERE deptno = 30);",
71,Wskazać poprawne zapytanie SQL znajdujące stanowiska pracy występujące w działach 10 lub 20. - (5)
,SELECT DISTINCT job FROM emp WHERE deptno = 10 OR deptno = 20,+
,SELECT DISTINCT job FROM emp WHERE deptno = 10 UNION SELECT DISTINCT job FROM emp WHERE deptno = 20,+
,SELECT DISTINCT job FROM emp WHERE deptno = 10 AND deptno = 20,
,SELECT DISTINCT job FROM emp WHERE deptno = 10 INTERSECT SELECT DISTINCT job FROM emp WHERE deptno = 20,
72,Wskazać poprawne zapytanie SQL znajdujące stanowiska pracy występujące zarówno w dziale 10 jak i w dziale 20. - (5)
,SELECT DISTINCT job FROM emp WHERE deptno = 10 INTERSECT SELECT DISTINCT job FROM emp WHERE deptno = 20,+
,SELECT DISTINCT job FROM emp WHERE deptno = 10 OR deptno = 20,
,SELECT DISTINCT job FROM emp WHERE deptno = 10 UNION SELECT DISTINCT job FROM emp WHERE deptno = 20,
,SELECT DISTINCT job FROM emp WHERE deptno = 10 AND deptno = 20,
73,"Wskazać poprawne zapytanie SQL znajdujące pracowników, którzy zarabiają mniej od swoich kierowników. - (0)"
,"SELECT e.ename prac_name, e.sal prac_sal, m.ename kier_name, m.sal kier_sal FROM emp e, emp m WHERE e.mgr = m.empno AND e.sal < m.sal",+
,"SELECT e.ename prac_name, e.sal prac_sal, m.ename kier_name, m.sal kier_sal FROM emp e, emp m WHERE e.mgr = m.empno AND m.sal < e.sal",
,"SELECT e.ename prac_name, e.sal prac_sal, m.ename kier_name, m.sal kier_sal FROM emp e, emp m WHERE e.mgr = m.mgr AND e.sal < m.sal",
,"SELECT e.ename prac_name, e.sal prac_sal, m.ename kier_name, m.sal kier_sal FROM emp e, emp m WHERE e.mgr = m.mgr AND m.sal < e.sal",
74,"Wskazać poprawne zapytanie SQL znajdujące średnie zarobki tylko tych departamentów, które zatrudniają więcej niż trzech pracowników. - (10)"
,"SELECT deptno, AVG(sal) FROM emp GROUP BY deptno HAVING COUNT (*) > 3;",+
,"SELECT deptno, AVG(sal) FROM emp HAVING COUNT (*) > 3;GROUP BY deptno ;",+
,"SELECT deptno, AVG(sal) FROM emp GROUP BY deptno WHERE COUNT (*) > 3;",
,"SELECT deptno, AVG(sal) FROM emp WHERE COUNT (*) > 3;GROUP BY deptno ;",
75,"Wskazać poprawne zapytanie SQL znajdujące stanowiska, na których średni zarobek wynosi 3000 lub więcej. - (5)"
,"SELECT job, AVG(sal) FROM emp GROUP BY job HAVING AVG (sal) > =3000;",+
,"SELECT job, AVG(sal) FROM emp HAVING AVG (sal) > =3000GROUP BY job;",+
,"SELECT job, AVG(sal) FROM emp GROUP BY job WHERE AVG (sal) > =3000;",
,"SELECT job, AVG(sal) FROM emp WHERE AVG (sal) > =3000 GROUP BY job;",
76,Wskazać poprawne zapytanie SQL znajdujące departamenty zatrudniające powyżej trzech pracowników - (4)
,"SELECT deptno, COUNT(*) FROM emp GROUP BY deptno HAVING COUNT (*) > 3;",+
,"SELECT deptno, COUNT(*) FROM emp HAVING COUNT (*) > 3 GROUP BY deptno;",+
,"SELECT deptno, COUNT(*) FROM emp GROUP BY deptno WHERE COUNT (*) > 3;",
,"SELECT deptno, COUNT(*) FROM emp WHERE COUNT (*) > 3 GROUP BY deptno;",
77,Wskazać poprawne zapytanie SQL znajdujące ilość pracowników w dziale mającym siedzibę w DALLAS. - (8)
,"SELECT COUNT (*) FROM emp, dept WHERE dept.loc = 'DALLAS' AND emp.deptno = dept.deptno GROUP BY dept.deptno;",+
,SELECT COUNT (*) FROM emp WHERE deptno = (SELECT deptno FROM dept WHERE .loc = 'DALLAS'),+
,"SELECT COUNT (*) FROM emp, dept WHERE dept.loc = 'DALLAS' GROUP BY dept.deptno;",
,"SELECT COUNT (*) FROM emp, dept WHERE emp.deptno = dept.deptno GROUP BY dept,deptno HAVING dept.loc = 'DALLAS';",
78,Wskazać poprawne zapytanie SQL znajdujące średni zarobek pracowników z drugiej klasy zarobkowej. - (11)
,"SELECT AVG(sal ) FROM emp, salgrade WHERE.grade = 2 AND sal BETWEEN losal AND hisal GROUP BY.grade",+
,"SELECT AVG(sal ) FROM emp, salgrade WHERE.grade = 2 AND sal > losal AND sal < hisal GROUP BY.grade",+
,"SELECT AVG(sal ) FROM emp, WHERE sal > (SELECT losal FROM salgrade WHERE.grade = 2) AND sal < (SELECT hisal FROM salgrade WHERE.grade = 2)",+
,"SELECT AVG(sal ) FROM emp, salgrade WHERE.grade = 2 AND sal BETWEEN losal AND hisal ;",+
79,Wskazać poprawne zapytanie SQL znajdujące trzech najlepiej zarabiających pracowników w firmie - ich nazwiska i pensje. - (0)
,"SELECT ename, sal FROM emp e WHERE 3 > (SELECT count (*) FROM emp WHERE e.sal < sal);",+
,"SELECT ename, sal FROM emp e WHERE count(*)<3",
,"SELECT ename, sal FROM emp e GROUP BY.deptno HAVING count(*)<3",
80,W bloku PL/SQL występują: - (2)
,"deklaracje klas,",
,"sekcja wyjątków,",+
,"instrukcje SQL,",+
,instrukcje SQL*Plus.,
81,Wśród instrukcji występujących w bloku PL/SQL mogą się znaleźć: - (5)
,"instrukcje SQL*Plus,",
,"deklaracje zmiennych,",+
,"instrukcja CREATE TABLE,",
,instrukcja COMMIT.,+
82,Wśród instrukcji występujących w bloku PL/SQL mogą się znaleźć: - (4)
,"instrukcja SET SERVEROUTPUT ON,",
,"instrukcja CREATE TABLE,",
,"instrukcja DBMS_OUTPUT.PUT_LINE('Początek transakcji'),",+
,instrukcja ROLLBACK.,+
83,Wśród instrukcji występujących w bloku PL/SQL mogą się znaleźć: - (8)
,"instrukcja warunkowa,",+
,"instrukcja CREATE TABLE,",
,"instrukcja SELECT Table_Name FROM User_Tables,",
,instrukcja ROLLBACK.,+
84,Wśród instrukcji występujących w bloku PL/SQL mogą się znaleźć: - (4)
,"podniesienie wyjątku,",+
,"deklaracje wyjątków,",+
,"instrukcja SELECT * FROM Osoby,",
,instrukcja ROLLBACK.,+
85,Kursor w PL/SQL jest to: - (9)
,"rodzaj procedury,",
,"nazwana instrukcja SQL,",
,"obszar roboczy używany do wykonania instrukcji SQL,",+
,narzędzie do podnoszenia wyjątków.,
86,Czy definicja kursora w PL/SQL może dotyczyć instrukcji: - (0)
,"INSERT,",
,"SELECT,",+
,"DELETE,",
,UPDATE.,
87,Nazwa kursora może się pojawić w następujących kontekstach: - (0)
,"OPEN nazwa_kursora,",+
,"SELECT nazwa_kursora,",
,"EXIT WHEN nazwa_kursora%NOTFOUND,",+
,GOTO nazwa_kursora.,
88,Klauzula WHERE CURRENT OF nazwa_kursora może wystąpić w instrukcji: - (0)
,"SELECT,",
,"INSERT,",
,"DELETE,",+
,UPDATE.,+
89,Nazwa wyjątku może się pojawić w następujących kontekstach; - (0)
,"w instrukcji przypisania,",
,"w definicji kursora,",
,"w instrukcji RAISE,",+
,"po słowie kluczowym WHEN,",+
90,Trigger (wyzwalacz) tabelowy może zostać uruchomiony: - (5)
,przed operacją na tabeli,+
,po operacji na tabeli,+
,bez związku z operacjami na tabeli,
,przed i po operacji na tabeli,
91,Dla każdej tabeli można określić - (2)
,maksymalnie 2 typy wyzwalaczy,
,maksymalnie 12 typów wyzwalaczy,+
,maksymalnie 12 wyzwalaczy,
,dowolną ilość wyzwalaczy,+
92,Polecenia ROLLBACK i COMMIT dotyczą poleceń SQL - (1)
,"tylko INSERT, UPDATE, SELECT",
,"tylko INSERT, UPDATE, SELECT, DELETE",
,"tylko SELECT, INSERT, UPDATE, SELECT, DELETE",
,wszystkich poleceń SQL zmieniających zawartość tabel,+
93,W PL/SQL wynik działania instrukcji SELECT może zostać zapisany w postaci - (3)
,tabeli,
,kursora,+
,perspektywy,
,zmiennej,+
94,"Klauzula ""DECLARE Dane_Osoby Osoba%ROWTYPE"" jest w PL/SQL - (5)"
,deklaracją zmiennej,
,deklatracją nowego rekordu,
,deklaracją nowego typu zmiennej,
,deklaracją zmiennej wraz z definicją jej typu,+
95,Kursor w PL/SQL to - (0)
,typ zmiennej,
,rodzaj procedury,
,obiekt o określonych właściwościach i metodach,+
,funkcja debuggera,
96,Instrukcja FETCH jest używana w kursorze PL/SQL w celu - (6)
,przejścia do następnego rekordu,+
,pobrania zawartości rekordu ze źródła danych,+
,przejścia do następnego rekordu i usunięcia poprzedniego rekordu,
,pobrania zawartości rekordu ze źródła danych i przejścia do następnego rekordu,+
97,Funkcja NVL służy do - (1)
,"Zamiany napotkanej w tabeli wartości ""NULL"" na zero",
,"Zamiany napotkanej w tabeli wartości z ""NULL"" na podaną w argumencie wartość",+
,"Zamiany wartości zmiennej z ""NULL"" na podaną w argumencie wartość",+
,"Zamiany wartości podanej w argumencie zmiennej lub komórki perspektywy z ""NULL"" na podaną w drugim argumencie wartość",
98,"Użycie klauzuli UNQUE w deklaracji pola tabeli instrukcji CREATE TABLE oznacza, że: - (6)"
,w tym polu nie może pojawić się wartość NULL,
,w żadnym innym polu tej tabeli nie można użyć klauzuli UNIQUE,
,wartości w tym polu nie mogą się powtarzać,+
,na tej kolumnie (polu) zostanie automatycznie zalozony indeks,+
99,"Użycie klauzuli PRIMARY KEY deklaracji pola tabeli instrukcji CREATE TABLE powoduje, że: - (4)"
,To pole staje się polem klucz głównego,+
,W żadnym innym polu tej tabeli nie może zostać użyta klauzula PRIMARY KEY,+
,"W polu yum nie może wystąpić wartość ""NULL""",+
,Na tej kolumnie (polu) zostanie automatycznie założony indeks,+
100,Perspektywa (View) w PL/SQL - (3)
,Jest obiektem przechowującym rekordy wybrane poleceniem SELECT,
,Jest obiektem utworzonym w oparciu o instrukcję SELECT,+
,"Może zostać użyta tak, jak by była tabelą np. w instrukcji SELECT, INSERT, UPDATE",+
,Wiersze (rekordy) perspektywy nie są przechowywane w bazie danych,+
101,Instrukcja SELECT Table_Name FROM User_Tables - (3)
,Wypisuje nazwy kolumn z tabeli User_Tables,
,Wypisuje wszystkie rekordy z perspektywy User_Tables,
,Zwraca nazwy tabel znajdujących się w obszarze tabel użytkownika,+
,Zwraca nazwy tabel utworzonych przez użytkownika,
102,Sekwencja (SEQUENCE) to - (3)
,Ciąg instrukcji SQL,
,"Obiekt PL/SQL przechowujący procedury, funkcje i wyzwalacze",
,"Obiekt przechowywyany w bazie danych, służący do generowania kluczy głównych i jednozancznych",+
,Typ zmiennej w PL/SQL której użycie generuje autonumerację rekordów tabeli,
103,Instrukcja COMMIT - (1)
,"Dotyczy ostatnio wydanego polecenia SELECT, UPDATE albo DELETE",
,"Dotyczy wszystkich poleceń SELECT, INSERT, UPDATE albo DELETE wydanych od ostatniego polecenia ROLLBACK",
,Dokonuje trwałej zmiany w zawartości table bazy danych,+
,"Wszystkich poleceń INSERT, UPDATE albo DELETE wydanych od ostatniego polecenia COMMIT albo ROLLBACK",+
104,Instrukcja CREATE PROCEDURE może się pojawić: - (3)
,"w bloku PL/SQL,",
,"w SQL*Plusie,",+
,"w innej procedurze,",
,w wyzwalaczu.,
105,Instrukcja CREATE FUNCTION może się pojawić: - (0)
,"w bloku PL/SQL,",
,"w SQL*Plusie,",+
,"w innej funkcji,",
,w wyzwalaczu.,
106,Instrukcja CREATE TRIGGER może się pojawić: - (4)
,"w bloku PL/SQL,",
,"w SQL*Plusie,",+
,"w procedurze,",
,w innym wyzwalaczu.,
107,Instrukcja CREATE PACKAGE może się pojawić: - (0)
,"w bloku PL/SQL,",
,w wyzwalaczu,
,"w innym pakiecie,",
,"w skrypcie SQL*Plus,",+
108,Instrukcja CREATE PACKAGE BODY może się pojawić: - (5)
,"w bloku PL/SQL,",
,w wyzwalaczu,
,"w skrypcie SQL*Plus,",+
,w pakiecie.,
109,W wyzwalaczu można: - (0)
,"poprosić użytkownika o podanie wartości zmiennej,",
,"na ekranie użytkownika formularza wypisać ostrzeżenie,",
,"sprawdzić czy wartości wstawiane do tabeli są poprawne,",+
,utworzyć nową tabelę.,
110,W wyzwalaczu można: - (3)
,"poprosić użytkownika o podanie hasła,",
,"na ekranie użytkownika wypisać komunikat o błędzie,",
,utworzyć nową tabelę.,
,porównać ze sobą nową i starą wartość w kolumnie przy UPDATE,+
111,W wyzwalaczu można: - (8)
,"użyć instrukcji COMMIT,",
,"nie dopuścić do wprowadzenia zmian,",+
,"sprawdzić czy wartości wstawiane do tabeli są poprawne,",+
,utworzyć nową tabelę.,
112,W wyzwalaczu można: - (0)
,"poprosić użytkownika o podanie wartości zmiennej,",
,"do kolumny klucza głównego tworzonego wiersza wygenerować nową wartość,",+
,"sprawdzić która jest godzina,",+
,utworzyć nową tabelę.,
113,W wyzwalaczu można: - (2)
,"zrealizować akcję referencyjną NULLIFY,",
,"przekazać informację o błędzie do aplikacji klienta,",+
,"sprawdzić czy w danej kolumnie wstawianego wiersza występuje NULL,",+
,utworzyć nowy wyzwalacz.,
114,Które mechanizmy wchodzą w skład oprogramowania strony serwera bazy danych: - (0)
,"formularze,",
,"deklaratywne więzy spójności,",+
,"wyzwalacze wierszowe,",+
,obiekty OCX.,
115,Wśród więzów spójności encji znajdują się: - (1)
,"więzy klucza głównego,",+
,"więzy klucza obcego,",
,"zdarzenia formularzowe,",
,więzy CHECK.,+
116,Wśród więzów spójności encji znajdują się: - (0)
,"więzy klucza obcego,",
,"więzy klucza jednoznacznego,",+
,"blokady,",
,więzy NOT NULL,+
117,Wśród więzów spójności referencyjnej znajdują się: - (0)
,"więzy klucza głównego,",
,"więzy klucza obcego,",+
,"więzy NOT NULL,,",
,więzy CHECK,
118,Do zapewnienia więzów spójności referencyjnej służą: - (4)
,"wyzwalacze,",+
,"klauzula CHECK,",
,"klauzula REFERENCES,",+
,indeksy.,
119,Do zapewnienia więzów spójności encji służą: - (2)
,"wyzwalacze,",+
,"klauzula CHECK,",+
,"klauzula REFERENCES,",
,indeksy.,
120,Które akcje referencyjne są dostępne w Oracle: - (3)
,"RESTRICTED,",
,"NULLIFY,",
,"DEFAULT,",
,CASCADE.,+
121,SQL*Plus stanowi: - (6)
,"część serwera bazy danych,",
,"część serwera aplikacji Oracle,",
,"język interakcyjnych poleceń do bazy danych,",+
,klient korzystający z serwera bazy danych.,
122,Deklaracja VARIABLE Klient VARCHAR2(30) jest częścią: - (0)
,"SQL,",
,"PL/SQL,",
,"SQL*Plus,",+
,prekompilatora do języka C.,
123,"Instrukcja ACCEPT Klient PROMPT ""Podaj nazwisko klienta: "" jest częścią: - (0)"
,"SQL,",
,"PL/SQL,",
,"SQL*Plus,",+
,prekompilatora do języka C.,
124,Kursor w PL/SQL służy do: - (0)
,"Wprowadzania danych z klawiatury,",
,Przeglądania i wykonywania operacji na rekordach zwróconych przez zapytanie.,+
,Przyspieszenia wykonywania zapytań.,
,Obsługi wyjątków.,
125,Obiektowa baza danych w Oracle obejmuje: - (0)
,"wielowymiarowość,",
,"kolekcje,",+
,"typy obiektowe,",+
,dziedziczenie.,+
126,Obiektowa baza danych w Oracle obejmuje: - (0)
,"tabele zagnieżdżone,",+
,"hermetyzację obiektów,",
,"perspektywy obiektowe,",+
,transformację STAR.,
127,W kolumnach bazy danych Oracle można przechowywywać: - (0)
,"duże obiekty binarne,",+
,"duże obiekty znakowe,",+
,"wskaźniki do obiektów,",+
,zagnieżdżone tabele.,+
128,Czy są takie instrukcje w Oracle: - (0)
,"CREATE TYPE,",+
,"CREATE CLASS,",
,"CREATE METHOD,",
,CREATE SERVLET.,
129,W bazie danych Oracle można zmieniać zawartość następujących typów obiektów: - (2)
,"BLOB,",+
,"CLOB,",+
,"BFILE,",+
,NCLOB.,+
130,Standard SQL określa następujące interfejsy programistyczne: - (0)
,"PL/SQL,",
,"Java,",
,"moduły,",+
,osadzony SQL.,+
131,Standard SQL określa następujące interfejsy programistyczne: - (4)
,"PL/SQL,",
,"Interfejs Poziomu Wywołań CLI,",
,"moduły,",+
,osadzony SQL.,+
132,Standard SQL określa następujące interfejsy programistyczne: - (3)
,osadzony SQL,+
,"ODBC,",
,JDBC.,
,Interfejs Poziomu Wywołań CLI,
133,Osadzanie instrukcji SQL w interfejsie osadzonego SQL dotyczy: - (0)
,"cache serwera bazy danych,",
,"słownika danych,",
,"języka programowania,",
,PL/SQL.,+
134,Instrukcje osadzonego SQL są poprzedzane słowem kluczowym: - (2)
,"EXEC,",
,"DO,",
,"EXEC SQL,",+
,BEGIN.,
135,"Instrukcja ""SQLExecDirect(hstmt, (SQLCHAR *) sqlsource, SQL_NTS)"" dotyczy języka: - (0)"
,"PL/SQL,",
,"osadzonego SQL,",
,"Interfejsu Poziomu Wywołań,",+
,ASP.,
136,Interfejs JDBC może być używany w: - (2)
,"apletach,",+
,"serwletach,",+
,"kodzie składowanym w bazie danych,",
,programach aplikacyjnych.,+
137,W JDBC zbiór wyników zapytania znajduje się na obiekcie klasy: - (0)
,"Rowset,",
,"RecordSet,",
,"ResultSet,",+
,QuerySet.,
138,"W zapytaniu ""SELECT HelloWorld() FROM Dual;"" identyfikator HelloWorld może oznaczać: - (3)"
,funkcję PL/SQL;,+
,klasę Java;,
,funkcję PL/SQL związaną z metodą klasy Java;,
,procedurę PL/SQL.,+
139,Jako obiekty bazy danych Oracle można przechowywać kod języków: - (0)
,"C,",+
,"Java,",+
,"PL/SQL,",+
,VisualBasic.,+
140,Aplikacja wykonywana za pomocą internetowego modułu PLSQL wykorzystuje: - (0)
,serwer WWW Apache;,
,powiązania ODBC,
,"powiązania bazodanowe,",+
,powiązania JDBC.,
141,Aplikacja wykonywana za pomocą internetowego modułu PLSQL wykorzystuje: - (0)
,"powiązania bazodanowe,",+
,"transformację STAR,",
,"procedury PL/SQL,",
,migawki.,
142,Aplikacja wykonywana za pomocą Internet Information Servera wykorzystuje: - (0)
,"ODBC,",
,"powiązania bazodanowe,",+
,"wielowymiarowość,",
,skrypty Visual Basica.,
143,Aplikacja ASP jest przechowywana jako: - (0)
,"plik tekstowy,",+
,"plik binarny,",
,"procedura w bazie danych,",
,biblioteka DLL.,
144,W internetowej aplikacji PL/SQL przy dostępie do danych w bazie danych wykorzystuje się: - (2)
,"protokół HTTP,",
,"metodę GET,",
,"instrukcję SELECT,",+
,kursor.,
145,Serwlet jest to: - (7)
,"aplet przechowywany po stronie serwera aplikacji,",
,"obiekt klasy HttpServlet,",+
,"metoda klasy HttpServlet,",
,rodzaj sterownika JDBC.,
146,Serwlet przy dostępie do danych w bazie danych wykorzystuje: - (1)
,serwer WWW Apache,
,protokół HTTP,
,"powiązania bazodanowe,",+
,powiązania JDBC.,
147,Programista aplikacji internetowej w postaci serwletu opracowuje kod metod: - (4)
,doGet,+
,doPost,+
,HttpServletRequest,+
,HttpServletResponse,+
148,Które metody dotyczą zachowania spójności danych przy współbieżnym dostępie: - (0)
,blokowanie pesymistyczne,+
,przyznawanie uprawnień do obiektów w bazie danych,
,autoryzowanie dostępu,
,blokowanie optymistyczne,+
149,Które metody dotyczą możliwości odtworzenia danych po awarii dysku: - (3)
,dziennik,+
,repliki,
,udostępnienie danych na stronach WWW,
,kopia zapasowa,+
150,Które metody dotyczą ochrony danych przed nieautoryzowanym dostępem: - (0)
,kopia zapasowa,
,wprowadzenie kont i haseł,+
,słownik danych (metadane),
,przyznawanie uprawnień do wykonywania operacji na obiektach,+
151,Własność szeregowalności transakcji oznacza: - (0)
,konieczność specyfikowania kolejności wykonywania transakcji,
,wymuszenie na systemie szeregowego wykonywania transakcji,
,współbieżną realizację transakcji tak jakby były one wykonywane jedna po drugiej,+
,ustalenie priorytetu wykonywania transakcji,
152,Dane słownika danych (metadane) są przechowywane w relacyjnej bazie danych: - (0)
,w specjalnym pliku binarnym w tym samym katalogu co pliki systemu zarządzania bazą danych,
,nie muszą być przechowywane w bazie danych,
,w specjalnej bazie danych (budowanej przez administratora),
,w specjalnych tabelach w tej samej bazie danych,+
153,Do odtworzenia stanu bazy danych po awarii procesu użytkownika służą: - (0)
,"dziennik powtórzeń,",
,"pliki śladu,",
,"segmenty wycofań,",+
,kopia zapasowa.,
154,Do odtworzenia stanu bazy danych po awarii procesu serwera służą: - (0)
,"dziennik powtórzeń,",+
,"pliki śladu,",
,"segmenty wycofań,",+
,kopia zapasowa.,
155,Do odtworzenia stanu bazy danych po awarii dysku z danymi służą: - (2)
,"dziennik powtórzeń,",+
,"pliki śladu,",
,"segmenty wycofań,",+
,kopia zapasowa.,+
156,Przy otwieraniu bazy danych przy powtórnym włączeniu komputera po nagłej awarii zasilania są używane: - (0)
,"dziennik powtórzeń,",+
,"pliki śladu,",
,"segmenty wycofań,",+
,kopia zapasowa.,
157,Rezerwowa baza danych pracująca w trybie STANDBY otrzymuje z głównej bazy danych: - (0)
,"pliki z danymi,",
,"dziennik powtórzeń,",
,"zarchiwizowany dziennik powtórzeń,",+
,nic nie otrzymuje.,
158,Poziom izolacji transakcji READ UNCOMMITED obejmuje następujące własności: - (0)
,"brak traconych modyfikacji,",+
,"nie-zatwierdzony odczyt,",+
,"nie-powtarzalny odczyt,",+
,fantomy.,+
159,Poziom izolacji transakcji READ COMMITED obejmuje następujące własności: - (2)
,"brak traconych modyfikacji,",+
,"nie-zatwierdzony odczyt,",
,"nie-powtarzalny odczyt,",+
,fantomy.,+
,"widać zmiany wprowadzane przez inne transakcje, o ile tamte zakończyły się zatwierdzeniem",+
160,Poziom izolacji transakcji REPEATABLE READ obejmuje następujące własności: - (0)
,"brak traconych modyfikacji,",+
,"nie-zatwierdzony odczyt,",
,"nie-powtarzalny odczyt,",
,fantomy.,+
161,Poziom izolacji transakcji SERIALIZABLE obejmuje następujące własności: - (0)
,"brak traconych modyfikacji,",+
,"nie-zatwierdzony odczyt,",
,"nie-powtarzalny odczyt,",
,fantomy.,
162,Domyślny poziom izolacji w Oracle obejmuje następujące własności: - (0)
,"brak traconych modyfikacji,",+
,"nie-zatwierdzony odczyt,",
,"nie-powtarzalny odczyt,",+
,fantomy.,+
163,Przy normalnym otwieraniu bazy danych system korzysta z informacji zapisanych w: - (0)
,"pliku kontrolnym,",
,"pliku śladu,",
,"dzienniku powtórzeń,",
,pliku inicjalizacyjnym instancji.,+
164,Które mechanizmy są używane do zapewnienia wielowersyjności w bazie danych: - (8)
,"dziennik powtórzeń,",+
,"pliki śladu,",
,"segmenty wycofań,",+
,kopia zapasowa.,
165,Które mechanizmy są używane w bazie danych przy wykonywaniu transakcji typu READ ONLY: - (0)
,"dziennik powtórzeń,",+
,"pliki śladu,",
,"segmenty wycofań,",+
,kopia zapasowa.,
166,Które mechanizmy są używane do zapewnienia spójności bazy danych w środowisku współbieżnie wykonywanych transakcji: - (0)
,"blokady,",+
,"perspektywy,",
,"role,",
,wielowersyjność.,+
167,Przy wykonywaniu operacji ROLLBACK są wykorzystywane: - (1)
,"dziennik powtórzeń,",+
,"segmenty wycofań,",+
,"kopia zapasowa,",
,pliki śladu.,
168,Terminy atomowość-spójność-izolacja-trwałość oznaczane skrótem ACID dotyczą: - (0)
,"modelu wykonywania transakcji w bazie danych,",+
,"modelu obliczeń w rozproszonej bazie danych,",
,"modelu wykonywania pojedynczej instrukcji SQL,",
,modelu sprawdzania więzów spójności.,
169,Czy jest prawdą: - (0)
,Z każdą stroną w puli buforów jest wiązany licznik odwołań i bit aktualizacji.,+
,Zmieniana strona jest natychmiast zapisywana na dysk.,
,Z jednej strony w puli buforów może korzystać tylko jeden użytkownik.,
,Zawsze najlepszą strategią zastępowania stron jest LRU.,
170,Czy format stron z rekordami zmiennej długości zapewnia: - (0)
,Przesuwanie rekordów po stronie bez zmiany identyfikatora rekordu.,+
,Utrzymywanie spójnej puli wolnych miejsc.,+
,Zamianę miejscami dwóch rekordów na stronie.,+
,Używanie zewnętrznych wskaźników do rekordu.,+
171,Indeks pogrupowany jest gdy: - (2)
,"pozycje danych są podzielone na osobne partycje,",
,"rekordy danych i pozycje danych indeksu są w związku 1-1,",
,"pozycje danych indeksu z tą samą wartością klucza wyszukiwania znajdują się na tej samej stronie,",
,uporządkowanie zapisu rekordów danych jest takie samo jak uporządkowanie zapisu pozycji danych indeksu.,+
172,Indeks na B+ drzewie zapewnia: - (1)
,"możliwość wypisywania pozycji danych indeksu w kolejności uporządkowanej względem wartości klucza wyszukiwania,",+
,"realizację zapytań równościowych względem wartości klucza wyszukiwania,",+
,"realizację zapytań zakresowych względem wartości klucza wyszukiwania,",+
,aktualizację wartości klucza wyszukiwania.,+
173,Indeks haszowany zapewnia: - (2)
,"możliwość wypisywania pozycji danych w kolejności uporządkowanej względem wartości klucza wyszukiwania,",+
,"realizację zapytań równościowych względem wartości klucza wyszukiwania,",
,"realizację zapytań zakresowych względem wartości klucza wyszukiwania,",
,aktualizację wartości klucza wyszukiwania.,+
174,Sortowania w bazie danych używa się przy: - (0)
,"wykonywaniu klauzuli GROUP BY,",+
,"budowie początkowego indeksu na B+-drzewie,",+
,"wykonywaniu klauzuli DISTINCT,",+
,metodzie złączania Nested Loops Join.,
175,Sortowania w bazie danych używa się przy: - (0)
,"wykonywaniu klauzuli ORDER BY,",+
,"budowie początkowego indeksu na B+-drzewie,",+
,"wykonywaniu klauzuli UNION DISTINCT,",+
,metodzie złączania Sort-Merge.,+
176,Sortowania w bazie danych używa się przy: - (0)
,"wykonywaniu klauzuli WHERE,",
,"budowie początkowego indeksu na B+-drzewie,",+
,"wykonywaniu klauzuli UNION ALL,",
,metodzie złączania Index Nested Loops Join.,
177,Sortowania w bazie danych używa się przy: - (0)
,"wykonywaniu klauzuli EXCEPT,",+
,"wykonywaniu klauzuli GROUP BY,",+
,"wykonywaniu klauzuli HAVING,",
,metodzie złączania Nested Loops Join.,
178,Sortowania w bazie danych używa się przy: - (3)
,"wykonywaniu klauzuli EXCEPT,",+
,"budowie początkowego indeksu na B+-drzewie,",+
,"wykonywaniu funkcji agregującej AVG,",
,metodzie złączania Hash Join.,
179,"Sortowanie za pomocą B+-drzewa jest lepsze niż sortowanie zewnętrzne, gdy indeks jest: - (0)"
,"rzadki,",
,"gęsty,",
,"pogrupowany,",+
,wewnętrzny.,+
180,"Strategia optymalizacyjna ""tylko-indeks"" stosuje się, gdy: - (0)"
,"na tabeli jest założony tylko jeden indeks,",
,"zamiast rozważać tabelę można rozważyć jeden z jej indeksów,",+
,"wszystkie kolumny występujące na liście SELECT występują w kluczu wyszukiwania jednego z indeksów,",+
,można usunąć tabelę zostawiając w bazie danych tylko jej indeks.,
181,W metodzie Hash Join występuje liczba funkcji haszujących równa: - (0)
,"0,",
,"1,",
,"2,",+
,3.,
182,Które stwierdzenia stanowią dobre heurystyki optymalizacji zapytań: - (0)
,"Selekcje wykonuj tak wcześnie, jak tylko możliwe.",+
,"Staraj się związać selekcje z iloczynem kartezjańskim, w celu zidentyfikowania rodzaju złączenia relacji.",+
,"Wybierz plan wykonania działający ""w miejscu"" bez pomocniczej relacji.",+
,Wyszukuj wspólne podwyrażenia i wykonuj je tylko raz.,+
183,Które stwierdzenia stanowią dobre heurystyki optymalizacji zapytań: - (0)
,Przed przystąpieniem do realizacji zapytania dokonaj analizy możliwych opcji z oszacowaniem ich kosztu.,+
,"Staraj się związać selekcje z iloczynem kartezjańskim, w celu zidentyfikowania rodzaju złączenia relacji.",+
,Wykonuj jednocześnie ciągi operacji jednoargumentowych takich jak selekcje i rzuty.,+
,"Przetwórz wstępnie plik we właściwy sposób (indeksy, sortowanie).",+
184,Które z poniższych stwierdzeń są prawdziwe: - (0)
,Przy warunkach zakresowych istotna jest kolejność atrybutów w kluczu wyszukiwania.,+
,Indeks haszowany na relacji wewnętrznej jest dobry dla metody Index Nested Loops Join.,+
,Pogrupowany indeks na B+ drzewie względem kolumn złączenia jest dobry dla metody Sort-Merge Join.,+
,Metoda Hash Join wymaga istnienia indeksu haszowanego.,
185,Które z poniższych stwierdzeń są prawdziwe: - (0)
,Metoda Sort-Merge Join wymaga istnienia indeksu na B+-drzewie.,
,Indeks pogrupowany jest użyteczny przy zapytaniach zakresowych a także przy mało-selektywnych zapytaniach równościowych.,+
,Aktualizacja pól wyszukiwania w indeksach spowalnia INSERT/DELETE/UPDATE.,+
,Tylko jeden indeks może być pogrupowany dla jednej tabeli.,+
186,Protokół ścisłego blokowania dwufazowego (Strict 2PL) obejmuje warunki: - (4)
,Każda transakcja musi uzyskać blokadę S na obiekcie zanim odczyta ten obiekt.,+
,"Jeśli transakcja trzyma blokadę X na obiekcie, żadna inna transakcja nie ma prawa założyć żadnej blokady (ani S ani X) na tym obiekcie.",+
,Aby założyć blokadę X transakcja musi zwolnić wszystkie swoje blokady S.,
,Blokady trzymane przez transakcję są zwalniane gdy tylko nie są jej potrzebne.,
,Każda transakcja musi uzyskać blokadę X na obiekcie przed zapisaniem go.,+
,Blokady trzymane przez transakcję są zwalniane gdy transakcja kończy się,+
187,Protokół ścisłego blokowania dwufazowego (Strict 2PL) obejmuje warunki: - (0)
,Każda transakcja musi uzyskać blokadę X na obiekcie zanim odczyta ten obiekt.,
,"Jeśli transakcja trzyma blokadę S na obiekcie, żadna inna transakcja nie ma prawa założyć żadnej blokady (ani S ani X) na tym obiekcie.",
,Blokady trzymane przez transakcję są zwalniane gdy transakcja kończy się.,+
,Z każdą blokadą X powinna być związana odpowiadająca jej blokada S ale nie na odwrót.,
188,Protokół ścisłego blokowania dwufazowego (Strict 2PL) obejmuje warunki: - (2)
,Każda transakcja musi uzyskać blokadę X na obiekcie przed zapisaniem go.,+
,"Jeśli transakcja trzyma blokadę S na obiekcie, żadna inna transakcja nie ma prawa założyć żadnej blokady (ani S ani X) na tym obiekcie.",
,Dwie współpracujące ze sobą transakcje mogą wspólnie założyć jedną blokadę X.,
,"W pierwszej fazie transakcja zakłada blokady, w drugiej fazie je zwalnia w dowolnej kolejności.",
189,Aby zapobiec zakleszczeniu (deadlock) wystarczy: - (0)
,"uzależniać założenie blokady od priorytetu transakcji,",+
,"uzależniać założenie nowej blokady od liczby założonych już przez transakcję blokad,",
,"pozwalać tylko jednej transakcji na założenie blokady X,",
,"sprawdzać, czy w grafie oczekiwania na zwolnienie blokady występuje cykl.",+
190,Fantomem nazywamy: - (2)
,"tabelę, do której nie ma dostępu żaden użytkownik,",
,"wiersz, który został usunięty z tabeli, po tym jak inna transakcja odczytała ją,",
,"wiersz, który został wpisany do tabeli, po tym jak inna transakcja odczytała ją,",+
,"wiersz, który został zmieniony, po tym jak inna transakcja odczytała ją.",
191,Który rodzaj złączenia jest dobry w rozproszonej bazie danych: - (0)
,"sort-merge join,",
,"hash join,",
,"półzłączenia,",+
,złączenie zewnętrzne.,
192,Czy jest prawdą dla protokołu dwu-fazowego zatwierdzania: - (3)
,"jest tylko jeden koordynator,",+
,"koordynator podejmuje decyzję ""commit"", gdy co najmniej jeden z węzłów przesłał mu komunikat ""yes"",",
,"koordynator podejmuje decyzję ""abort"", gdy wszystkie węzły nadesłały komunikat ""no"",",
,w przypadku awarii sieci jest potrzebna dodatkowa trzecia faza.,
193,Czy jest prawdą dla protokołu dwu-fazowego zatwierdzania: - (0)
,"jeden węzeł wyróżnia się jako główny koordynator, a drugi jako zapasowy koordynator,",
,"koordynator podejmuje decyzję ""commit"", gdy każdy z węzłów przysłal mu komunikat ""yes"",",+
,"tylko koordynator zapisuje komunikaty realizacji protokołu do swojego dziennika powtórzeń,",
,w przypadku awarii koordynatora jego funkcje przejmuje inny węzeł.,
194,Czy jest prawdą: - (0)
,Bufory bazy danych zawierają używane ostatnio bloki danych z bazy danych.,+
,"Bufory bazy danych mogą zawierać zmodyfikowane dane zatwierdzonych transakcji, które jeszcze nie zostały przepisane na dysk.",+
,Bufory bazy danych zmienione przez niezatwierdzone transakcje mogą zostać przepisane na dysk.,+
,W buforach bazy danych są zapisywane pozycje segmentów wycofań.,+
195,Segmenty wycofań służą do: - (1)
,"wycofywania nie zatwierdzonych zmian przy odtwarzaniu,",+
,"zagwarantowania spójności odczytu,",+
,"realizacji transakcji korzystających ze zdjęcia migawkowego danych,",+
,przyśpieszenia wykonywania zapytań.,
196,Które z mechanizmów są używane w rozproszonej bazie danych: - (0)
,"dyspozytor,",
,"powiązanie bazodanowe,",+
,wielowersyjność,
,audyt.,
197,Które z mechanizmów są używane w rozproszonej bazie danych: - (3)
,"replikacja danych,",+
,"blokady,",+
,"transformacja STAR,",
,partycjonowanie tabeli.,
198,Które z mechanizmów są używane w rozproszonej bazie danych: - (0)
,klaster,
,"migawki,",+
,"instrukcja ANALYZE,",
,serwer równoległy.,
199,Które z mechanizmów są używane w rozproszonej bazie danych: - (0)
,"indeks bitmapowy,",
,"powiązanie bazodanowe,",+
,"hurtownia danych,",
,agregacja danych.,
200,Które z mechanizmów są używane w rozproszonej bazie danych: - (0)
,"równoległe wykonywanie zapytań,",
,"dwufazowe zatwierdzanie,",+
,"dziennik migawki,",+
,audyt.,
201,Które z mechanizmów są charakterystyczne dla hurtowni danych: - (0)
,"replikacja danych,",
,"blokady,",
,"transformacja STAR,",+
,partycjonowanie tabeli.,+
202,Które z mechanizmów są charakterystyczne dla hurtowni danych: - (1)
,"blokady,",
,"perspektywy,",
,"role,",
,indeksy bitmapowe.,+
203,Które z mechanizmów są charakterystyczne dla hurtowni danych: - (0)
,"histogram,",+
,"audyt,",
,"agregacje,",+
,profil.,
204,Które z mechanizmów są charakterystyczne dla hurtowni danych: - (0)
,"instrukcja ANALYZE,",+
,"szeregowalność,",
,"wielowymiarowość,",+
,dziennik powtórzeń.,
205,Które z mechanizmów są charakterystyczne dla hurtowni danych: - (1)
,"role,",
,"wielowymiarowość,",+
,"migawki,",+
,schemat gwiazda.,+
206,Które obiekty są związane z agregacją w hurtowni danych: - (3)
,"indeks bitmapowy,",
,"perspektywa zmaterializowana,",+
,"klaster,",
,klauzula GROUP BY.,+
207,"Dane są tabele P(A,B), Q(B,C). W aplikacji często jest wykonywane zapytanie SELECT P.A,Q.C FROM P, Q WHERE P.B=Q.B AND Q.B='&Klient'. Która ze struktur danych byłaby najkorzystniejsza: - (0)"
,"indeksy na P.B, Q.B;",
,"indeksy na P.A, Q.C;",
,klaster obejmujący P i Q z indeksem B;,+
,indeks na Q.B.,
208,"Dane są tabele P(A,B), Q(B,C). W aplikacji często jest wykonywane zapytanie SELECT P.A,Q.C FROM P, Q WHERE P.B=Q.B. Która ze struktur danych byłaby najkorzystniejsza: - (4)"
,"indeksy na P.B, Q.B;",
,"indeksy na P.A, Q.C;",+
,klaster obejmujący P i Q z indeksem B;,
,indeks na P.B.,
209,"Dane są tabele P(A,B), Q(B,C). W aplikacji często jest wykonywane zapytanie SELECT P.A,Q.B FROM P, Q WHERE P.B=Q.B AND Q.C='&Klient'. Która ze struktur danych byłaby najkorzystniejsza: - (0)"
,"indeksy na P.B, Q.B;",
,"indeksy na P.B, Q.C;",+
,klaster obejmujący P i Q z indeksem B;,
,indeks na Q.C.,
210,"Zastosowanie indeksu przy wyszukiwaniu jest uzasadnione, gdy dzięki niemu ograniczamy się do: - (0)"
,>=50% ogólnej liczby wierszy w tabeli.,
,<=50% ogólnej liczby wierszy w tabeli.,
,<=25% ogólnej liczby wierszy w tabeli.,+
,>=25% ogólnej liczby wierszy w tabeli.,
211,"Zastosowanie strategii tylko indeks jest stosowane, gdy: - (0)"
,"na tabeli nie jest założony żaden indeks,",
,"wyszukiwanie jest określone na perspektywie,",
,"wyszukiwanie sprowadza się do przejścia indeksu,",+
,wstawianie sprowadza się do wstawienia do indeksu.,
212,Indeks bitmapowy zakłada się na kolumnie: - (4)
,"w której liczba różnych wartości jest duża,",
,"w której liczba różnych wartości jest mała,",+
,"gdy wyszukiwanie jest określane przez równość z podanymi wartościami,",+
,gdy zachodzi konieczność sortowania względem wartości w tej kolumnie.,
213,Indeks używający B-drzewa zakłada się na kolumnie: - (0)
,"gdy wyszukiwanie po tej kolumnie daje zwykle duży zbiór wyników,",
,"gdy wyszukiwanie po tej kolumnie daje zwykle mały zbiór wyników,",+
,"gdy wyszukiwanie często dotyczy największej wartości,",+
,gdy często sortuje się dane względem tej kolumny.,+
214,Czy istniejący indeks przyśpiesza wykonanie instrukcji SELECT: - (0)
,"nigdy,",
,"zawsze,",
,czasem.,+
215,Czy istniejący indeks przyśpiesza wykonanie instrukcji INSERT: - (3)
,"nigdy,",
,"zawsze,",
,czasem.,+
216,Czy istniejący indeks przyśpiesza wykonanie instrukcji UPDATE: - (0)
,nigdy,
,zawsze,
,czasem,+
217,Czy istniejący indeks przyśpiesza wykonanie instrukcji DELETE: - (0)
,nigdy,
,zawsze,
,czasem,+
218,Czy istniejący indeks przyśpiesza wykonanie instrukcji ROLLBACK: - (0)
,nigdy,+
,zawsze,
,czasem,
219,Czy istniejący indeks przyśpiesza wykonanie instrukcji COMMIT: - (0)
,nigdy,+
,zawsze,
,czasem,
220,Użycie których metod może spowodować zmniejszenie liczby przesłań między pamięcią wewnętrzną i zewnętrzną: - (0)
,"użycie perspektywy,",
,"indeks na kolumnie klucza obcego,",+
,"zwykły indeks oparty na B-drzewie dla kolumny o dwóch wartościach,",
,indeks bitmapowy na kolumnie zawierającej nazwiska klientów.,
221,Użycie których metod może spowodować zmniejszenie liczby przesłań między pamięcią wewnętrzną i zewnętrzną: - (0)
,"zwiększenie liczby buforów,",+
,"klaster,",+
,"indeks bitmapowy na kolumnie zawierającej płeć klientów,",+
,wykonanie instrukcji SET TRANSACTION READ ONLY.,
222,Użycie których metod może spowodować zmniejszenie liczby przesłań między pamięcią wewnętrzną i zewnętrzną: - (0)
,"dodatkowa tabela pomocnicza,",+
,"indeks bitmapowy na kolumnie zawierającej płeć klientów,",+
,"wykonanie instrukcji SET TRANSACTION READ ONLY,",
,zwykły indeks oparty na B-drzewie dla kolumny zawierającej nazwiska osób.,+
223,Użycie których metod może spowodować zmniejszenie liczby przesłań między pamięcią wewnętrzną i zewnętrzną: - (0)
,"indeks bitmapowy na kolumnie zawierającej kraj, w którym mieszkają klienci,",+
,"wykonanie instrukcji ANALYZE,",+
,"wykonanie instrukcji SET TRANSACTION READ ONLY,",
224,Ile warunków złączeń potrzeba w zapytaniu aby uniknąć złączenia kartezjańskiego? - (0)
,liczba tabel minus jeden,+
,liczba kolumn minus jeden,
,liczba kolumn plus jeden,
,liczba tabel plus jeden,
225,Który z poniższych operatorów zwróci część wspólną wyników zapytań A i B zadanych w Oraclu? - (0)
,INTERSECT,+
,MINUS,
,UNION,
,UNION ALL,
226,Polecenie RENAME TABLE służy do: - (0)
,zmiany nazwy tabeli,+
,w Oraclu nie ma polecenia pozwalającego na zmianę nazwy tabeli,
,usunięcia tabeli,
,usunięcia danych z tabeli,
227,Perspektywa w PL/SQL: - (0)
,"może zostać użyta tak, jak by była tabelą np. w instrukcji SELECT, INSERT, UPDATE",+
,jest obiektem przechowującym rekordy wybrane poleceniem SELECT,
,jest obiektem utworzonym w oparciu o instrukcję SELECT,+
,wiersze (rekordy) perspektywy nie są przechowywane w bazie danych,+
228,"Które z poniższych klauzul muszą wystąpić przed GROUP BY (zakładając, że chcemy, aby w ogóle wystąpiły)? - (15)"
,INTO,
,FROM,+
,HAVING,
,WHERE,+
229,"SELECT ename, NVL(sal, 0) ""Salary"" FROM Emp WHERE Sal IS NULL ORDER BY ename; - (4)"
,0,+
,nic nie zwróci,
,spację,
,null,
230,Który z poniższych operatorów zwróci sumę zapytań bez eliminacji powtarzających się wierszy? - (0)
,MINUS,
,UNION ALL,+
,UNION,
,INTERSECT,
231,Wśród instrukcji występujących w bloku PL/SQL (między BEGIN i END) mogą się znaleźć: - (0)
,instrukcja DELETE FROM EMP,+
,obsługa wyjątku,+
,podniesienie wyjątku,+
,deklaracje klas,
232,W jaki sposób tworzy się funkcję: - (0)
,CREATE FUNCTION nazwa(lista parametrów) IS,
,CREATE FUNCTION nazwa(lista parametrów) AS,
,CREATE FUNCTION nazwa(lista parametrów) RETURN Typ IS,+
,CREATE FUNCTION nazwa(lista parametrów) RETURN Typ AS,+
233,Używając instrukcji LOCK TABLE można: - (0)
,dokonać blokady wybranego pojedynczego wiersza,
,dokonać blokady dowolnej liczby wierszy,
,dokonać blokady tabeli przed nieuprawnionym dostępem,
,dokonać blokady tabeli w trybie wyłączności,+
234,W Oracle przy wykonywaniu instrukcji CREATE PROCEDURE: - (4)
,są zakładane blokady wyłączne na występujące w treści procedury tabele,
,są zakładane blokady współdzielone na występujące w treści procedury tabele,+
,nie są zakładane żadne blokady na występujące w treści procedury tabele,
,nie są zakładane blokady jeśli w treści występują tylko instrukcje SELECT,
235,Jakie są rodzaje parametrów procedur - (2)
,out,+
,null,
,in out,+
,in,+
236,Zawartość tabeli tymczasowej może zostać zniszczona - (5)
,za pomocą instrukcji delete,
,na koniec sesji,+
,na koniec transakcji,+
,po powtórnym zalogowaniu do bazy,
237,Co będzie wynikiem realizacji instrukcji SELECT * FROM Emp WHERE EmployeeID = EmployeeID OR EmployeeID = NULL - (3)
,relacja Emp,+
,instrukcja jest niepoprawna,
,null,
,relacja pusta,
238,Które z poniższych klauzul mogą (ewentualnie muszą) wystąpić przed GROUP BY w Oraclu? - (2)
,WHERE,+
,ORDER BY,
,HAVING,+
,FROM,+
239,Transakcja w bazie danych: - (13)
,jest zakładana automatycznie przez serwer baz danych od ostatniej instrukcji DML,
,zmiana zatwierdzona przez COMMIT może być ('cośtam') wycofane przez ROLLBACK,
,to ciąg instrukcji DML i DQL wykonywanych w bazie danych,
,mogą być zatwierdzane przez programistę na żądanie,
240,Które z poniższych twierdzeń dotyczących polecenia TRUNCATE TABLE są prawdziwe? - (4)
,można wycofać jego działanie instrukcją ROLLBACK,
,można nim usunąć tylko całą zawartość tablicy,+
,jest szybsze niż polecenie DELETE TABLE,+
,nie można w nim stosować klauzuli WHERE,+
241,"Jaki będzie efekt wykonania następującego polecenia: CREATE TABLE Osoby (imie VARCHAR2(30) PRIMARY KEY, nazwisko VARCHAR2(30) PRIMARY KEY, zarobki NUMBER(7,2)) - (2)"
,przy próbie wykonania polecenia wystąpi błąd,+
,"zostanie stworzona tabela Osoby, której kluczem głównym będzie pole imie",
,"zostanie stworzona tabela Osoby, której kluczem głównym będzie zbiór złożony z pól (imie, nazwisko)",
,"zostanie stworzona tabela Osoby, której kluczem głównym będzie pole nazwisko",
242,W którym z poniższych zapytań jest użyte złączenie zewnętrzne między dwiema tabelami (w Oraclu)? - (9)
,"SELECT region.region_name, employee.salary FROM region, employee WHERE employee.salary BETWEEN region.avg_salary AND region.max_salary;",
,"SELECT region.region_name, employee.salary FROM region, employee WHERE region.id = employee.region_no;",+
,"SELECT region.region_name, employee.salary FROM region, employee WHERE region.id = employee.region_no;",
,"SELECT region.region_name, employeeinfo.last_name FROM employee region, employee employeeinfo WHERE employeeinfo.id >= region.manager_id;",
243,Poziom izolacji transakcji READ COMMITED obejmuje następujące własności: - (0)
,widać wszystkie modyfikacje wprowadzane przez równolegle trwające transakcje,
,nie można w nim modyfikować danych w bazie danych,
,"widać zmiany wprowadzane przez inne transakcje, o ile tamte zakończyły się zatwierdzeniem",+
244,Klauzula START WITH określa: - (0)
,korzeń drzewa,+
,na jakim poziomie drzewa znajduje się dany wiersz w stosunku do wiersza stanowiącego korzeń,
,syna dla ojca,
245,"Wykonujesz następujące zapytanie:SELECT e1.ename||' pracuje dla' ||e2.ename ""Pracownicy i ich szefowie"" FROM emp e1, emp e2 WHERE e1.mgr=e2.empno;Jaki to jest rodzaj złączenia? - (0)"
,kartezjańskie,
,zewnętrzne,
,samozłączenie,+
246,W którym z poniższych zapytań jest użyte złączenie zewnętrzne między dwiema tabelami (w Oraclu)? - (6)
,"SELECT region.region_name, employee.salary FROM region, employee WHERE region.id = employee.region_no;",
,"SELECT region.region_name, employee.salary FROM region, employee WHERE region.id = employee.region_no;",+
,"SELECT region.region_name, employeeinfo.last_name FROM employee region, employee employeeinfo WHERE employeeinfo.id >= region.manager_id;",
,"SELECT region.region_name, employee.salary FROM region, employee WHERE employee.salary BETWEEN region.avg_salary AND region.max_salary;",
247,Relacja R ma atrybut a. Jaka liczba może być wynikiem wykonania instrukcji SELECT Count(*) FROM R WHERE a=a - (3)
,zawsze tyle jaka jest liczebność relacji R,
,dowolna liczba naturalna,+
,1,+
,0,+
248,Jakie nazwiska zostaną wyświetlone w wyniku tego zapytania: SELECT ename FROM emp WHERE ename LIKE '_A%'; - (2)
,"nazwiska, w których litera A występuje na dowolnym miejscu poza pierwszym",
,"nazwiska, w których litera A występuje na drugim miejscu",+
,nazwiska kończące się na A,
,nazwiska zaczynające się na A,
249,Wyzwalacz w T-SQL jest uruchamiany - (4)
,"Po wykonaniu, ale przed zatwierdzeniem polecenia DML",+
,Przed wykonaniem polecenia DML,
,"Po wykonaniu, ale nie można określicz czy przed czy po zatwierdzeniu",
,Po wykonaniu i zatwierdzeniu polecenia DML,
250,"Która z poniższych instrukcji w PL/SQL nie zakończy się błędem, przy założeniu, że w tabeli DEPTNO są dwa rekordy z wartościami Deptno IN (10, 20) oraz prawidłowej deklaracji zmiennej v_deptno - (10)"
,SELECT deptno INTO v_deptno FROM dept WHERE deptno>0;,
,SELECT deptno INTO v_deptno FROM dept WHERE deptno=10;,+
,SELECT deptno INTO v_deptno FROM dept;,
,"SELECT deptno INTO v_deptno FROM dept WHERE deptno IN (10, 20);",
251,"Problem fantomów dotyczy sytuacji, w której: - (5)"
,W trakcie działania transakcji inna transakcja wstawiła nowy rekord,+
,W trakcie działania transakcji inna transakcja usunęła rekord,
,"Uzytkownik zobaczył rekord wprowadzony przez innego użytkownika, który nie został zatwierdzony przez COMMIT",
,Rekord został w obrębie jednej transakcji wprowadzony (INSERT) i od razu usunięty (DELETE),
252,Wyniki procedury T-SQL mogą być zwrócone przez - (5)
,Zmienną typu OUTPUT,+
,Zmienną wiązania,
,Dyrektywę RETURN,+
,Result Set,+
253,Kopia zapasowa dziennika transakcji: - (4)
,"Jest bezużyteczna, jeśli nie odtworzymy wcześniej pełnej kopii zapasowej",+
,Pozwala wyczyścić dziennik transakcji,+
,Zawiera zmiany w bazie danych wykonane od ostatniej kopii zapasowej dziennika transakcji,+
,Zawiera zmiany w bazie danych wykonane od ostatniej kopii różnicowej,
254,Pakiet w PL/SQL - (2)
,W pakiecie mogą być definiowane podprogramy (funkcje i procedury),+
,Zmienne zadeklarowane w części prywatnej pakietu są widoczne w jego części publicznej,
,Część prywatna (ciało) pakietu jest opcjonalna,+
,Zmienne zadeklarowane w części publicznej pakietu są widoczne w jego części prywatnej,+
255,"Zintegrowanie w definicji hurtowni danych oznacza, że: - (1)"
,dane są jednolite,+
,"dane, raz umieszczone w hurtowni, zazwyczaj pozostają nie zmienione",
,"zbierane dane dotyczą tematu, a nie działań",
,gromadzone są dane historyczne i każdy fakt opatrzony jest stemplem czasowym,
256,W procedurze (PROCEDURE) PL/SQL - (7)
,Domyślnym typem parametru jest IN OUT,+
,Deklarując parametr procedury nie podaje się jego typu,
,Deklarując parametr procedury można mu nadać wartość domyślną,+
,Jedynym typem parametru jest IN OUT,
257,W funkcji (FUNCTION) PL/SQL - (4)
,Zwracana jest wartość wyrażenia znajdującego się po instrukcji RETURN,+
,Wywołanie funkcji odbywa się przez jej nazwę,+
,Można użyć instrukcji DQL,+
,Nie można zadeklarować parametru typu OUT,
258,Zaznacz poprawne stwierdzenia: - (3)
,Każda instrukcja SELECT wymaga pobrania danych z dysku twardego,
,Wynik działania każdej instrukcji UPDATE jest natychmiast po zatwierdzeniu zapisywany w pliku z danymi,
,Wynik działania każdej instrukcji SELECT jest zapisywany w dzienniku transakcji,
,Wynik działania każdej instrukcji UPDATE jest natychmiast po zatwierdzeniu zapisywanyw dzienniku transakcji,+
259,Które z poniższych instrukcji wypisze tekst Ala123 w SQL Server? - (3)
,Print 'Ala' + '123';,+
,Print 'Ala' + Cast(123 As Varchar);,+
,Print 'Ala' + 123;,
,Print 'Ala' + Cast (1+2+3 As Varchar);,
260,"Dane są dwie tabele Osoby(Imie, Nazwisko, Zarobki, Id_działu) oraz Działy(Id_działu, Nazwa). Które z następujących instrukcji są poprawnymi instrukcjami SQL w Oracle - (2)"
,"SELECT Osoby.Nazwisko, Działy.Nazwa FROM Osoby, Działy, WHERE Osoby.Id_działu =Działy.Id_działu GROUP BY Osoby.Nazwisko HAVING COUNT (Działy.Id_działu) < 2;",
,UPDATE Osoby SET Id_działu = NULL WHERE 5>(SELECT COUNT(*) FROM Działy);,+
,DELETE FROM Osoby WHERE Osoby.Nazwisko='KOWALSKI' AND Działy.Id_działu=22;,
,"INSERT INTO Osoby VALUES ('Jan', 'Kowalski', 2000);",
261,Które z poniższych instrukcji w SQL Server jest składniowo poprawna (zostanie wykonana) - (1)
,SELECT empno FROM emp WHERE empno=empno;,+
,SELECT 1 FROM emp WHERE 1<>1;,+
,SELECT 1 FROM emp WHERE 1=1;,+
,SELECT empno FROM emp WHERE empno<>empno;,+
262,Wskazać poprawne zapytanie SQL (dialekt ORACLE) znajdujące dla każdego departamentu ostatnio zatrudnionych pracowników - (3)
,"SELECT deptno, ename, hiredate FROM emp WHERE hiredate = (SELECT MAX(hiredate) FROM emp GROUP BY deptno);",
,"SELECT deptno, ename, hiredate FROM emp WHERE (hiredate, deptno) IN (SELECT MAX(hiredate), deptno FROM emp GROUP BY deptno);",+
,"SELECT deptno, ename, hiredate FROM emp e WHERE hiredate = (SELECT MAX(hiredate) FROM emp WHERE deptno=e.deptno)",+
,"SELECT deptno, ename, MAX(hiredate) FROM emp GROUP BY deptno;",
263,Zaznacz poprawne stwierdzenia dotyczące typów LOB: - (6)
,Istnieją specjalne funkcje operujące na danych LOB.,+
,Można utworzyć wiele kolumn LOB w jednej tabeli.,+
,"Na rekordach zawierających dane LOB działają instrukcje SELECT, INSERT, UPDATE, DELETE.",+
,Kolumna LOB może wystąpić wyłącznie w tabeli typu obiektowego.,
264,Zaznacz poprawne stwierdzenia dotyczące wielowersyjności w bazach danych: - (4)
,MS SQL Server realizuje poziom izolacji READ COMMITTED przy pomocy wielowersyjności.,
,"MS SQL Server oferuje mechanizm, dzięki któremu możemy tworzyć statyczne obrazy (migawki) bazy danych, oparte na wielowersyjności.",+
,Oracle realizuje poziom izolacji READ COMMITTED przy pomocy wielowersyjności.,+
,Poziom izolacji SERIALIZABLE w MS SQL Server jest realizowany przy pomocy wielowersyjności.,
265,Aby posortować wyniki zapytania w odwrotnym porządku leksykograficznym przy nazwie sortowanej kolumny należy wpisać: - (6)
,"nic nie trzeba wpisywać, to domyślny sposób sortowania",
,DESC,+
,ASC,
266,W jaki sposób tworzy się perspektywę z opcją sprawdzania: - (0)
,pisząc na końcu polecenia tworzenia perspektywy: WITH MAKE SURE OPTION,
,pisząc na końcu polecenia tworzenia perspektywy: WITH PROVE CORRECT OPTION,
,"nie trzeba nic pisać, ponieważ jest to opcja domyślna",
,pisząc na końcu polecenia tworzenia perspektywy: WITH CHECK OPTION,+
267,Jakie znaczenie ma dziennik transakcji w serwerach baz danych? - (0)
,Pozwala zachować spójność danych po awarii,+
,Pozwala wycofywać transakcje,+
,Pozwala zarządzać uprawnieniami,
,Pozwala na odtworzenie stanu bazy danych z określonego punktu w czasie,+
268,Które ze stwierdzeń jest prawdziwe: - (0)
,perspektywa to to samo co tabela,
,używając perspektyw możemy w ogóle nie dbać o inne sposoby ochrony danych,
,perspektywy stanowią element ochrony danych przed niepowołanym lub nieprawidłowym dostępem do danych,+
,wiersze perspektywy mogą być wyliczane na żądanie,+
269,Znormalizowany schemat bazy danych: - (0)
,jest zawsze najbardziej wydajny.,
,schemat bazy danych nie ma wpływu na wydajność.,
,można poprawić wydajność zapytań do znormalizowanej bazy danych stosując perspektywy zmaterializowane.,+
,może być mniej wydajny niż schemat nieznormalizowany.,+
270,Która z poniższych instrukcji w SQL Server jest składniowo poprawna (zostanie wykonana) - (7)
,DELETE FROM emp WHERE empno = NULL;,+
,TRUNCATE emp;,+
,"INSERT INTO emp (ename, job) SELECT ename, job FROM emp;",+
,UPDATE emp SET sal = sal WHERE sal = sal;,+
271,Która z poniższych instrukcji PL/SQL prawidłowo podstawia wartość na zmienną (w tabeli EMP jest 14 rekordów)? - (4)
,SELECT ename INTO v_ename FROM emp;,
,SELECT v_ename = ename FROM emp WHERE empno = 1234;,
,DECLARE v_ala Varchar2(10) := 'Ala';,+
,SELECT ename INTO v_ename FROM dummy;,+
272,Rola w bazie danych: - (0)
,"Jest grupą obiektów bazy danych (tabel, procedur, perspektyw)",
,Jest obiektem bazy danych pozwalającym łatwiej zakładać indeksy,
,Jest grupą użytkowników,+
,Może mieć nadane uprawnienia,+
273,Procedura T-SQL zwraca poprzez Result Set - (0)
,Wszystkie wiersze ostatniej uruchomionej wewnątrz procedury instrukcji SELECT,+
,Poprzez Result Set mogą być zwracane wyłącznie komunikaty o błędach,
,Procedura może zwrócić wyniki tylko poprzez zmienną OUTPUT,
,Ostatni wiersz ostatniej uruchomionej wewnątrz procedury instrukcji SELECT,
274,W wyzwalaczu T-SQL - (0)
,Mogą być deklarowane zmienne,+
,Można używać instrukcji ROLLBACK,+
,Można używać kursororów,+
,Można używać instrukcji DML,+
275,Serwer baz danych może zarządzać współbieżnością dzięki: - (0)
,denormalizacji,
,materializacji,
,wielowersyjności,+
,rolom,
276,Które aksjomaty ACID są zapewnione przez użycie planu szeregowalnego: - (0)
,atomowość,
,spójność,+
,izolacja,+
,trwałość,
277,Czy replikacja przyśpiesza wykonywanie: - (0)
,instrukcji SELECT,+
,instrukcji INSERT,
,instrukcji DELETE,
,instrukcji UPDATE,
278,"Dane są dwie tabele Osoby(Imie, Nazwisko, Zarobki, Id_działu) oraz Działy(Id_działu, Nazwa). Które z następujących instrukcji są poprawnymi instrukcjami SQL w Oracle: - (5)"
,"SELECT Osoby.Nazwisko, Działy.Id_działu FROM Osoby, Działy WHERE Osoby.Id_działu=Działy.Id_działu GROUP BY Osoby.Nazwisko",
,"DELETE FROM Osoby, Działy WHERE Osoby.Nazwisko='KOWALSKI' AND Działy.Nazwa='KASA'",
,UPDATE Osoby SET Id_działu=NULL,+
,"INSERT INTO Osoby VALUES ('Jan', 'Kowalski', 2000)",
279,"Dana jest tabela Osoby(Imie, Nazwisko, Zarobki). Które z następujących instrukcji są składniowo poprawnymi instrukcjami SQL w Oracle: - (2)"
,UPDATE Osoby Nazwisko=USER,
,"INSERT INTO Osoby VALUES ('Jan', 'Kowalski', 2000) WHERE USER = 'KOWALSKI'",
,DELETE FROM Osoby WHERE USER='KOWALSKI',+
,"SELECT Osoby.Nazwisko, Osoby.Imie, Osoby.Zarobki FROM Osoby WHERE Osoby.Zarobki >1000",+
280,Które z poniższych stwierdzeń są prawdziwe: - (0)
,należy starać się użyć najmniejszej możliwej liczby tabel,
,należy wszystkie związki jednoznaczne zastąpić związkami jednojednoznacznymi,należy wszystkie związki jednoznaczne zastąpić związkami jednojednoznacznymi,,
należy wszystkie związki jednoznaczne zastąpić związkami jednojednoznacznymi,
,w tabeli nie powinno być żadnych niekontrolowanych redundancji,+
,"jedyną poprawną, nietrywialną zależnością funkcyjną jest zależność do klucza",+
281,"Użycie klauzuli PRIMARY KEY w deklaracji pola tabeli instrukcji CREATE TABLE powoduje, że: - (0)"
,w żadnym innym polu tej tabeli nie może zostać użyta klauzula PRIMARY KEY,+
,w polu tym nie może wystąpić wartość ?NULL?,+
,na tej kolumnie zostanie automatycznie założony indeks,+
,to pole staje się kluczem głównym,+
282,Wśród więzów spójności encji znajdują się: - (0)
,więzy klucza jednoznacznego,+
,więzy NOT NULL,+
,więzy CHECK,+
,"więzy klucza głównego,",+
283,"Które z poniższych klauzul muszą wystąpić przed GROUP BY (zakładając, że chcemy, aby w ogóle wystąpiły)? - (1)"
,INTO,+
,FROM,+
,WHERE,+
,HAVING,
284,"Jaką wartość dla kolumny ""Salary"" zwróci to zapytanie?SELECT ename, NVL(sal, 0) ""Salary"" FROM Emp WHERE Sal IS NULL ORDER BY ename; - (0)"
,0,0,+
0
,spację,
,nic nie zwróci,nic nie zwróci,,
nic nie zwróci,
,null,
285,Sortowania w bazie danych używa się przy: - (0)
,budowie początkowego indeksu na B+-drzewie,+
,wykonywaniu klauzuli UNION DISTINCT,+
,wykonywaniu klauzuli ORDER BY,+
,metodzie złączania Sort-Merge,+
286,Instrukcja FETCH jest używana w kursorze PL/SQL w celu: - (0)
,pobrania zawartości rekordu ze źródła danych i usunięcia poprzedniego rekordu,
,pobrania zawartości rekordu ze źródła danych i przejścia do następnego rekordu,pobrania zawartości rekordu ze źródła danych i przejścia do następnego rekordu,,+
pobrania zawartości rekordu ze źródła danych i przejścia do następnego rekordu,
,pobrania zawartości rekordu ze źródła danych,+
,przejścia do następnego rekordu,+
287,Instrukcja FETCH jest używana w kursorze PL/SQL w celu: - (0)
,pobrania zawartości rekordu ze źródła danych,+
,usunięcia poprzedniego rekordu,
,pobrania zawartości rekordu ze źródła danych i przejścia do następnego rekordu,pobrania zawartości rekordu ze źródła danych i przejścia do następnego rekordu,,+
pobrania zawartości rekordu ze źródła danych i przejścia do następnego rekordu,
,przejścia do następnego rekordu,+
288,"Jaki będzie efekt wykonania następującego polecenia:CREATE TABLE Osoby(imie VARCHAR2(30) PRIMARY KEY, nazwisko VARCHAR2(30) PRIMARY KEY, zarobki NUMBER(7,2)) - (6)"
,"zostanie stworzona tabela Osoby, której kluczem głównym będzie pole imie","zostanie stworzona tabela Osoby, której kluczem głównym będzie pole imie",
"zostanie stworzona tabela Osoby, której kluczem głównym będzie pole imie"
,"zostanie stworzona tabela Osoby, której kluczem głównym będzie pole nazwisko",
,"zostanie stworzona tabela Osoby, której kluczem głównym będzie zbiór złożony z pól (imie, nazwisko)",
,przy próbie wykonania polecenia wystąpi błąd,+
289,Relacja R ma atrybut a. Jaka liczba może być wynikiem wykonania instrukcji SELECT Count(*) FROM R WHERE a=a - (2)
,zawsze tyle jaka jest liczebność relacji R,zawsze tyle jaka jest liczebność relacji R,,
zawsze tyle jaka jest liczebność relacji R,
,0,+
,1,+
,dowolna liczba naturalna,+
290,Wskazać poprawne zapytanie SQL (w Oracle) znajdujące stanowiska pracy występujące zarówno w dziale 10 jak i w dziale 20. - (0)
,SELECT DISTINCT job FROM emp WHERE deptno = 10 AND deptno = 20,
,SELECT DISTINCT job FROM emp WHERE deptno = 10 INTERSECT SELECT DISTINCT job FROM emp WHERE deptno = 20,+
,SELECT DISTINCT job FROM emp WHERE deptno = 10 UNION SELECT DISTINCT job FROM emp WHERE deptno = 20,
,SELECT DISTINCT job FROM emp WHERE deptno = 10 OR deptno = 20,
291,Ile warunków złączeń potrzeba w zapytaniu aby uniknąć złączenia kartezjańskiego? - (0)
,w ogóle,
,liczba tabel plus jeden,
,liczba tabel minus jeden,+
,liczba kolumn minus jeden,
292,"Wskazać poprawne zapytanie SQL (w Oracle) znajdujące stanowiska, na których średni zarobek wynosi 3000 lub więcej. - (5)"
,"SELECT job, AVG(sal) FROM emp HAVING AVG (sal) >= 3000 GROUP BY job","SELECT job, AVG(sal) FROM emp HAVING AVG (sal) >= 3000 GROUP BY job",+
"SELECT job, AVG(sal) FROM emp HAVING AVG (sal) >= 3000 GROUP BY job"
,"SELECT job, AVG(sal) FROM emp GROUP BY job WHERE AVG (sal) >= 3000","SELECT job, AVG(sal) FROM emp GROUP BY job WHERE AVG (sal) >= 3000",,
"SELECT job, AVG(sal) FROM emp GROUP BY job WHERE AVG (sal) >= 3000",
,"SELECT job, AVG(sal) FROM emp WHERE AVG (sal) >= 3000 GROUP BY job",
,"SELECT job, AVG(sal) FROM emp GROUP BY job HAVING AVG (sal) >= 3000","SELECT job, AVG(sal) FROM emp GROUP BY job HAVING AVG (sal) >= 3000",,+
"SELECT job, AVG(sal) FROM emp GROUP BY job HAVING AVG (sal) >= 3000",
293,Kursor w PL/SQL jest to: - (0)
,rodzaj procedury,
,typ zmiennej,
,obszar roboczy używany do wykonania instrukcji SQL,obszar roboczy używany do wykonania instrukcji SQL,,+
obszar roboczy używany do wykonania instrukcji SQL,
,narzędzie do podnoszenia wyjątków,
294,Kursor w PL/SQL jest to: - (0)
,rodzaj procedury,
,typ zmiennej,
,obszar roboczy używany do wykonania instrukcji SQL,obszar roboczy używany do wykonania instrukcji SQL,,+
obszar roboczy używany do wykonania instrukcji SQL,
,narzędzie do podnoszenia wyjątków,
295,Kursor w PL/SQL to: - (0)
,obiekt o określonych właściwościach i metodach,+
,rodzaj procedury,
,funkcja debuggera,
,typ zmiennej,
296,"Wskazać poprawne (w Oraclu) zapytanie SQL znajdujące średnie zarobki tylko tych departamentów, które zatrudniają więcej niż trzech pracowników. - (2)"
,"SELECT deptno, AVG(sal) FROM emp HAVING COUNT (*) > 3 GROUP BY deptno;",+
,"SELECT deptno, AVG(sal) FROM emp GROUP BY deptno HAVING COUNT (*) > 3;",+
,"SELECT deptno, AVG(sal) FROM emp GROUP BY deptno WHERE COUNT (*) > 3;","SELECT deptno, AVG(sal) FROM emp GROUP BY deptno WHERE COUNT (*) > 3;",,
"SELECT deptno, AVG(sal) FROM emp GROUP BY deptno WHERE COUNT (*) > 3;",
297,Wśród instrukcji występujących w bloku PL/SQL (między BEGIN a END) mogą się znaleźć: - (2)
,instrukcja CREATE TABLE,instrukcja CREATE TABLE,
instrukcja CREATE TABLE
,instrukcja COMMIT,+
,instrukcje SQL*Plus,
,deklaracje zmiennych,
298,Czy istniejący indeks przyśpiesza wykonanie instrukcji COMMIT? - (0)
,czasem,czasem,,
czasem,
,zawsze,zawsze,,
zawsze,
,nigdy,+
299,W którym z poniższych zapytań jest użyte złączenie zewnętrzne między dwiema tabelami (w Oraclu)? - (2)
,"SELECT region.region_name, employee.salary FROM region, employee WHERE region.id = employee.region_no(+);",+
,"SELECT region.region_name, employee.salary FROM region, employee WHERE employee.salary BETWEEN region.avg_salary AND region.max_salary;",
,"SELECT region.region_name, employeeinfo.last_name FROM employee region, employee employeeinfo WHERE employeeinfo.id >= region.manager_id;",
,"SELECT region.region_name, employee.salary FROM region, employee WHERE region.id = employee.region_no;",
300,Czy istniejący indeks przyśpiesza wykonanie instrukcji DELETE? - (0)
,zawsze,
,czasem,czasem,,+
czasem,
,nigdy,
301,Jaka jest wartość wyrażenia NOT Null? - (2)
,False,
,NULL,+
,True,
,jest nieokreślone,
302,Które metody dotyczą ochrony danych przed nieautoryzowanym dostępem? - (0)
,wprowadzenie kont i haseł,+
,słownik danych,
,kopia zapasowa,
,przyznawanie uprawnień do wykonywania operacji na obiektach,przyznawanie uprawnień do wykonywania operacji na obiektach,,+
przyznawanie uprawnień do wykonywania operacji na obiektach,
303,W którym z poniższych przypadków konieczne jest umieszczenie tekstu w apostrofach (w Oraclu)? - (0)
,odwołanie do zmiennej typu CHAR w klauzuli WHERE,odwołanie do zmiennej typu CHAR w klauzuli WHERE,+
odwołanie do zmiennej typu CHAR w klauzuli WHERE
,odwołanie do zmiennej numerycznej w klauzuli WHERE,
,wyświetlenie myślnika (-) między dwoma połączonymi kolumnami,+
,wskazanie nazw kolumn w klauzuli SELECT,
304,W wyzwalaczu T-SQL: - (0)
,Mogą byc deklarowane zmienne.,+
,Można uzywać instrukcji DML.,+
,Można używać kursorów.,+
,Można używać instrukcji ROLLBACK,+
305,Jakie znaczenie ma dziennik powtórzeń w serwerach baz danych? - (0)
,Pozwala wycofywać transakcje.,+
,Pozwala na odtworzenie stanu bazy danych z określonego punktu w czasie.,+
,Pozwala zarządzać uprawnieniami.,
,Pozwala zachować spójność danych po awarii.,+
306,Zaznacz poprawne stwierdzenia dotyczące kopii zapasowych w MS SQL Server: - (0)
,"Kopia różnicowa zawiera zmiany miedzy podstawowym plikiem z danymi (mdf), a dodatkowym plikiem z danymi (ndf).",
,Kopia różnicowa zawiera zmiany w bazie danych wykonane od ostatniej kopii pełnej.,+
,Kopia różnicowa zawiera zmiany w bazie danych wykonane od poprzedniej kopii różnicowej.,
,Kopia różnicowa zawiera zmiany w bazie danych wykonane od ostatniej kopii dziennika transakcji.,
307,Partycjonowanie tabel polega na: - (0)
,Podziale tabeli na wiele części względem wartości w wierszach.,+
,Podziale tabeli na schemat oraz zawartość.,
,Podziale tabeli na wiele plików dyskowych.,+
,Podziale tabel na wiele częsci względem kolumn.,
308,W funkcji (FUNCTION) PL/SQL: - (0)
,Funkcje definiowane w bazie danych moga być użyte w poleceniach SQL.,+
,Nazwa funkcji może zostać przeciążona.,+
,Można użyć instrukcji DQL.,+
,Nie można zadeklarować parametru typu OUT.,+
309,Jakie są podstawowe składowe diagramów związków encji? - (0)
,związki,+
,atrybuty,+
,encje,+
310,Jaki rodzaj związku binarnego jest elementarnym związkiem w hierarchii encji? - (0)
,związek jedno-jednoznaczny oznaczany symbolem jest.,+
,związek weloznaczny,
311,W nagłówku bloku anonimowego w PL/SQL może wystąpić : - (2)
,TRY,
,DECLARE,+
,BEGIN,+
,CATCH,
312,Wśród instrukcji występujących w bloku PL/SQL mogą się znaleźć: - (0)
,instrukcja COMMIT,+
,"instrukcja DBMS_OUTPUT.PUT_LINE(‘Początek transakcji’),",+
,instrukcja ROLLBACK.,+
,instrukcja warunkowa,+
313,"Które z następujących elementów: atrybuty, encje, związki mogą być argumentami związków? - (0)"
,atrybuty dekryptywne,+
,encje,+
,związki,+
314,Jak nazywa się notacja zapisu zapytań używana przy ich optymalizacji? - (0)
,selekcja,
,algebra zapytań,+
315,Jakie są specjalne notacje zapytań? - (0)
,QBE,+
,rachunek relacyjny,+
,algebra relacji,+
316,Jaki jest model podstawowej jednostki danych poziomu fizycznego bazy danych? - (3)
,rekord składający się z pól określonych typów danych,+
,tabela,
317,Implementacja migawki prostej z opcją REFRESH FAST w głównej bazie danych wymaga utworzenia: - (0)
,perspektywy,
,indeksu,
,dziennika migawki,+
318,Problem fantomów dotyczy sytuacji w - (0)
,W trakcie działania transakcji inna transakcja wstawiła nowy rekord,+
,W trakcie działanie transkacji inna usunęła rekord,
,"Użytkownik zobaczyl rekord wprowadzony przez innego użytkownika, który nie został zatwierdzony przez COMMIT",
,Rekord został w obrębie jednej transkacji wprowadzony (INSERT) i od razu usunięty (DELETE),
319,"Która z instrukcji PL/SQL nie zakończy się błędem , przy założeniu że w tabelki DEPTNO są dwa rekordy z wartościami Deptno IN (10,20) oraz prawidłowej deklaracji zmiennej v_deptno - (6)"
,SELECT deptno INTO v_deptno FROM dept WHERE deptno = 10;,+
,SELECT deptno INTO v_deptno FROM dept WHERE deptno > 10;,+
,SELECT deptno INTO v_deptno FROM dept WHERE deptno < 20;,+
,SELECT deptno INTO v_deptno FROM dept WHERE deptno = 30;,
320,Która z poniższych instrukcji PL/SQL prawidłowo podstawia wartość na zmienną (w tabeli EMP jest 14 rekordów) ? - (3)
,SELECT ename INTO v_ename FROM emp;,
,V_ala Varchar2(10) := ‘Ala’;,+
,SELECT ename INTO v_name FROM emp WHERE empno = 1234;,+
,SELECT v_ename = ename FROM emp WHERE empno = 1234;,
321,"Użycie klauzuli UNIQUE w deklaracji pola instrukcji CREATE TABLE oznacza , że : - (0)"
,Wartości w tym polu nie mogą się powtarzać;,+
,Na tej kolumnie zostanie automatycznie założony indeks,+
,W żadnym innym polu tej tabeli nie można użyć klauzuli UNIQUE,
,W tym polu nie może pojawić się wartość NULL,
322,Procedura T-SQL zwraca poprzez Result Set : - (0)
,Procedura może zwrócić wynik tylko poprzez zmienna OUTPUT,
,Wszystkie wiersze ostatniej uruchomionej wewnątrz procedury instrukcji SELECT,+
,Poprzez Result Set mogą być zwracane wyłącznie komunikaty o błędach,
,Ostatni wiersz ostatniej uruchomionej wewnątrz procedury instrukcji SELECT,
323,"Która z poniższych instrukcji jest poprawna w T-SQL , jeżeli zostały prawidłowo zadeklarowane zmienne @empno i @deptno ? - (0)"
,SELECT @empno = 100;,+
,SELECT @empno = @empno;,+
,SELECT @empno = empno FROM emp;,+
,SELECT @empno = Max(empno) FROM emp;,+
324,"Dane są trzy tabele Klienci ( Id_Klienta, Imie , Nazwisko ), Produkty (Id_Produktu , Nazwa , Cena ) oraz Zakupy (Id_Klienta , Id_Produktu , Ilosc ) . Wskaż poprawne zapytania SQL znajdujące nazwy i ceny produktów , które zostały zakupione przez przynajmniej jednego klienta . - (0)"
,"SELECT DISTINCT Nazwa , Cena FROM Zakupy RIGHT OUTER JOIN Produkty ON Produkty.Id_Produktu = Zakupy.Id_Produktu;",
,"SELECT DISTINCT Nazwa , Cena FROM Produkty, Zakupy WHERE Produkty.Id_Produktu = Zakupy.Id_Produktu;",+
,"SELECT DISTINCT Nazwa , Cena FROM Produkty, Klienci;",
,"SELECT DISTINCT Nazwa , Cena FROM Produkty INNER JOIN Zakupy ON Produkty.Id_Produktu = Zakupy.Id_Produktu;",+
325,Które z poniższych stwierdzeń jest prawidłowe w PL/SQL ? - (7)
,Prawidłową konstrukcję pętli jest WHILE warunek BEGIN ciąg instrukcji END,
,Prawidłową konstrukcję pętli jest LOOP ciąg instrukcji END LOOP;,+
,Prawidłową konstrukcję pętli jest FOR i IN x … y ciąg instrukcji END LOOP;,
,Prawidłową konstrukcję pętli jest WHILE warunek LOOP ciąg instrukcji END LOOP;,+
326,Wskaż poprawne zapytanie SQL (dialekt Oracle) znajdujące pracowników zarabiających minimalną pensję na ich stanowiskach pracy : - (0)
,"SELECT ename , job , sal FROM emp WHERE (sal,job) IN (SELECT MIN(sal) , job FROM emp GROUP BY job );",+
,"SELECT ename, job MIN(sal) FROM emp GROUP BY job;",
,"SELECT ename, job, sal FROM emp WHERE sal = (SELECT MIN(sal) FROM emp GROUP BY job);",
,"SELECT ename , job, sal FROM emp e WHERE sal = (SELECT MIN(sal) From emp WHERE job = e.job);",+
327,Co należy do zalet synonimów? - (0)
,Są środkiem do realizacji niezależności fizycznej danych.,
,Ochraniają przed niepowołanym lub nieprawidłowym dostępem do danych.,
,Są środkiem do realizacji niezależności logicznej danych.,+
,Umożliwiają zdefiniowanie poziomu zewnętrznego bazy danych.,+
328,Do zakładania blokad służą konstrukcje: - (0)
,ROLLBACK,
,FOR UPDATE,+
,LOCK TABLE,+
,COMMIT,
329,"Treść pytaniaTabela (relacja) {Klucze - dużymi literami}. Dany schemat relacyjny Książka (NAZWISKO_AUTORA, TYTUŁ, Imie_Autora, Kategoria) z zależnościami funkcyjnymi F = { Nazwisko_Autora -> Imie_Autora Nazwisko_Autora, Tytuł -> Kategoria } jest w: - (0)"
,drugiej postaci normalnej,
,trzeciej postaci normalnej,
,pierwszej postaci normalnej,+
330,Poziom izolowanej transakcji można ustawić za pomocą instrukcji: - (0)
,ALTER SESSION,
,SET ISOLATION LEVEL,+
,CREATE TRANSACTION,
331,Jakie są role zdefiniowane przez system: - (4)
,CONNECT,+
,RESOURCE,+
,DBA,+
332,Wśród uprawnień przyznawanych w instrukcji GRANT występują: - (1)
,ALTER,+
,EXECUTE,+
,COMMIT,+
333,"Napisanie w SQL*Plus - describe tabela, spowoduje: - (0)"
,wyświetlenie schematu tabeli,+
,utworzenie schematu tabeli,
,wyświetlenie tylko nazw kolumn w tabeli,
334,Tabele PAŃSTWO i RZEKA ( i relacja przepływa przez) połączone są relacją - (3)
,jeden - wiele,
,wiele - jeden,
,wiele- wiele,
,wymagającą dodatkowej tabeli łączącej,+
335,"Klauzula ""DECLARE Dane_Osoby Osoba%ROWTYPE"" jest w PL/SQL: - (4)"
,deklatracją nowego rekordu,
,deklaracją nowego typu zmiennej,
,deklaracją zmiennej wraz z definicją jej typu,+
,deklaracją zmiennej,+
336,Które z mechanizmów są używane w hurtowni danych: - (0)
,"transformacja STAR,",+
,partycjonowanie tabeli.,+
,"histogram,",+
,"agregacje,",+
337,Które z mechanizmów są używane w hurtowni danych: - (0)
,indeksy bitmapowe.,+
,"instrukcja ANALYZE,",+
,"wielowymiarowość,",+
,schemat gwiazda.,+
338,Pakiet w PL/SQL - (0)
,Składa się z części publicznej (specyfikacji pakietu) i prywatnej (ciała pakietu),+
,Deklaracja zmiennych może odbywać się w części publicznej pakietu,+
,Deklaracja zmiennych może odbywać się w części prywatnej pakietu,+
339,Opcja sprawdzania użyta przy definiowaniu perspektywy ma znaczenie przy wykonywaniu: - (0)
,instrukcji SELECT,
,instrukcje DELETE,
,instrukcji INSERT,+
,instrukcji UPDATE,+
340,Co należy do zalet perspektyw? - (0)
,Są środkiem do realizacji niezależności fizycznej danych.,
,Umożliwiają zdefiniowanie poziomu zewnętrznego bazy danych.,+
,Ochraniają przed niepowołanym lub nieprawidłowym dostępem do danych.,+
,Są środkiem do realizacji niezależności logicznej danych.,+
341,"Tabela (relacja) {Klucze - dużymi literami}. Dany schemat relacyjny Pracownik (DOWOD_OSOBISTY, Nazwisko, Adres_Prac, Nr_Działu, Nazwa_Działu), z zależnościami funkcyjnymi F = { Dowod_Osobisty -> Nazwisko, Dowod_Osobisty -> Adres_Prac, Dowod_Osobisty -> Nr_Działu, Nr_Działu -> Nazwa_Działu} jest w: - (2)"
,drugiej postaci normalnej,
,postaci B-C,
,pierwszej postaci normalnej,
,trzeciej postaci normalnej,
342,Zdjęcie blokady założonej na tabeli następuje: - (5)
,po wykonaniu ROLLBACK,+
,po zapisaniu zmiany do bazy danych,
,po zmianie hasła,
,po wykonaniu COMMIT,+
343,"Jak dostać się z zewnątrz do procedury Zatrudnij z parametrami IdPracownika, Nazwisko, Pensja, NrDziału będącej w pakiecie ObsługaPracownika: - (9)"
,nie da się do niej dostać z zewnątrz,
,"ObsługaPracownika.Zatrudnij(1000, 'Kowalski', 2000, 10)",
,"Zatrudnij(1000, 'Kowalski', 2000, 10)",
,"GOTO ObsługaPracownika EXEC Zatrudnij(1000, 'Kowalski', 2000, 10)",
344,Które własności wchodzą w skład aksjomatów wykonywania transakcji: - (6)
,skalowalność,
,zabezpieczenie przed nieuprawnionym dostępem,
,wydajność,
,spójność,+
345,"Z ilu tabel powinna się składać prosta znormalizowana baza zawierająca informacje o częściach, urządzeniach i przynależności ""wiele do wielu"" między nimi: - (2)"
,2,
,4,
,1,
,3,+
346,Która z poniższych instrukcij prawidłowo utworzy tabelę tymczasową w T-SQL - (7)
,CREATE TABLE #Ala (Ala Int);,+
,CREATE TABLE ##Ala (Ala Int);,+
,"SELECT ename, sal INTO #Ala FROM emp;",+
,CREATE TABLE Ala (Ala Int);,
347,W procedurze (PROCEDURE) PL/SQL - (0)
,Deklarując parametr procedury nie podaje się jego typu,
,Jedynym typem parametru jest IN OUT,
,Deklarując typ parametru procedury nie podaje się jego rozmiaru,+
,Nazwa procedury może zostać przeciążona,+
348,Która z poniższych instrukcij jest składniowo poprawna w T-SQL - (1)
,IF 1 = 1 PRINT 'OK.';,+
,IF NULL = NULL PRINT 'OK';,+
,IF @empno = @empno PRINT 'OK';,+
,WHEN 1 = 1 THEN Print 'OK';,
349,Zaznacz poprawne stwierdzenia dotyczące przestrzeni tabel (Oracle) oraz grup plików (MS SQL): - (0)
,Przestrzeń tabel ma zawsze określony dokładnie jeden plik dyskowy,
,Grupie plików odpowiada zawsze dokładnie jeden fizyczny dysk twardy,
,Do przestrzeni tabel można przypisać wiele plików dyskowych,+
,Do przestrzeni tabel można przydzielić określone tabele bazy danych,+
350,Błąd w PL/SQL - (0)
,który wystąpił w bloku pomiedzy BEGIN i END jest obsługiwany w sekcji EXCEPTION tego samego bloku,+
,który wystąpił w sekcij deklaracji bloku jest przekazywany do bloku nadrzędnego,+
,który wystąpił w bloku pomiedzy BEGIN i END jest przekazywany do bloku nadrzędnego,
,który wystąpił w sekcji deklaraji bloku jest obsługiwany w sekcji EXCEPTION tego samego bloku,
351,Wskazać poprawne zapytanie SQL (dialekt ORACLE) znajdujące departamenty zatrudniające powyżej trzech pracowników - (2)
,"SELECT deptno, COUNT(*) FROM emp WHERE COUNT (*) > 3 GROUP BY deptno;",
,"SELECT deptno, COUNT(*) FROM emp GROUP BY deptno HAVING COUNT (*) > 3;",+
,"SELECT deptno, COUNT(*) FROM emp GROUP BY deptno WHERE COUNT (*) > 3;",
,"SELECT deptno, job, COUNT(*) FROM emp GROUP BY deptno, job HAVING COUNT(*) > 3;",
352,Które z ponizszych sformułowań jest prawdziwe - (0)
,Kursor umożliwia nawigację po zestawie rekordów odczytanych z bazy,+
,Kursor umożliwia odczytanie wielu wierszy z bazy,+
,Kursor jest buforem przechowującym rekordy odczytane z bazy,+
,Kursor umożliwia podstawienie na zmienne wartości wszystkich pól z rekordu odczytanego z bazy,+
353,"Dane są trzy tabele Klienci(Id_Klienta, Imie, Nazwisko), Produkty(Id_Produktu, Nazwa, Cena) oraz Zakupy(Id_Klienta, Id_Produktu, Ilosc). Wskaż poprawne zapytania SQL znajdujące imiona i nazwiska klientów, którzy zakupili co najmniej jeden produkt. - (0)"
,"SELECT DISTINCT Imie, Nazwisko FROM Klienci, Zakupy;",
,"SELECT DITINCT Imie, Nazwisko FROM Klienci LEFT OUTER JOIN Zakupy ON Klienci.Id_Klienta = Zakupy.Id_Klienta;",
,"SELECT DISTINCT Imie, Nazwisko FROM Klienci, Produkty, WHERE Klienci.Id_Klienta = Produkty.Id_Produktu;",
,"SELECT DISTINCT Imie, Nazwisko FROM Klienci, Zakupy , Produkty, WHERE Klienci.Id_Klienta = Zakupy.Id_Klienta AND Produkty.Id_Produktu = Zakupy.Id_Produktu;",+
354,Obiekt bedący generatorem jednoznacznych numerów w Oracle tworzony jest przy pomocy polecenia: - (0)
,CREATE AUTONUMBER,
,CREATE SUCCESSION,
,CREATE SEQUENCE,+
,CREATE AUTOCOUNTER,
355,Która z poniżych instrukcji w SQL Server jest składniowo poprawna (zostanie wykonana) - (0)
,SELECT empno FROM emp WHERE empno = empno;,+
,SELECT 1 FROM emp WHERE 1 <> 1;,+
,SELECT 1 FROM emp WHERE 1 = 1;,+
,SELECT empno FROM emp WHERE 1 = 'Ala';,
356,Deklaracja zmiennej w T-SQL - (0)
,"po jednej dyrektywie DECLARE może pojawić się kilka nazw zmiennych wraz z typami danych, rozdzielonych przecinkami",+
,może pojawić się w dowolnym miejscu bloku po dyrektywie DECLARE,+
,może wystąpić wyłącznie w wydzielonej sekcji DECLARE,
,musi zawierać określenie typu danych zmiennej,+
357,Więzy spójności mogą być definiowane w nastepujących instrukcjach: - (2)
,ALTER USER,
,UPDATE,
,CREATE TABLE,+
,DROP TABLE,
358,Polecenia ROLLBACK i COMMIT dotyczą poleceń SQL - (0)
,wszystkich poleceń SQL zmieniających zawartość tabel,+
,"tylko UPDATE, SELECT, DELETE",
,"tylko INSERT, SELECT, DELETE",
,"tylko INSERT, UPDATE, SELECT",
359,Zaznacz poprawne stwierdzenia dotyczące wielowersyjności w bazach danych: - (0)
,Poziom izolacji SERILIZABLE w MS SQL Server jest realizowany przy pomocy wielowersyjności.,
,Oracle realizuje poziom izolacji READ COMMITTED przy pomocy wielowersyjności.,+
,Oracle oferuje poziom izolacji READ ONLY oparty ma mechanizmie wielowersyjności.,+
,Przy zarządzaniu współbieżnością opartym na wielowersyjności procesy odczytujące mogą działać bez zakładania blokad.,+
360,Które z poniższych słów moga być nagłówkami sekcji w bloku anonimowym PL/SQL - (0)
,BEGIN,+
,EXCEPTION,+
,TRY,
,DECLARE,+
361,W wyzwalaczu T-SQL można aktualizować dane: - (7)
,Z poziomu wyzwalacza nie wolno zmieniać danych w żadnych tabelach,
,Tylko w tabelach INSERTED i DELETED,
,"Tylko w tabeli, z którą jest związany wyzwalacz",
,"We wszystkich tabelach, poza INSERTED i DELETED",+
362,Które z poniższych instrukcji może zostać użyta w bloku PL/SQL? - (0)
,SELECT,+
,ALTER,
,DROP,
,COMMIT,+
363,Które z poniższych stwierdzeń jest prawdziwe w PL/SQL? - (0)
,"W instrukcji warunkowej polecenia po THEN wykonywane są wówczas, gdy warunek przyjmuje wartość TRUE",+
,"Jeżeli w instrukcji warunkwej wartością warunku jest NULL, wówczas nie zostaną wykonane instrukcje po THEN ani po ELSE.",
,"W instrukcji warunkowej polecenie po ELSE wykonywane są wówczas, gdy warunek przyjmuje wartość FALSE lub NULL",+
,"Jeżeli w instrukcji warunkowej wartością warunku jest NULL, wówczas zostaną wykonane instrukcje po THEN",
364,Instrukacja MERGE - (1)
,Jest zaimplementowana tylko w PL/SQL,
,Pozwala zrezygnować z używania instrukcji INSERT i UPDATE,
,Opiera się na koncepji porównania rekordów w źródle danych (tabeli lub widoku) i obiekcie docelowym (tabeli lub widoku),+
,Jest zaimplementowana zarówno w T-SQL jak i PL/SQL,+
365,Wyzwalcz INSTEAD OF - (1)
,działa identycznie jak wyzwalacz tybu BEFORE,
,"może być stworzony, any umożliwić wykonanie instrukcji DML na perspektywie",+
,Jest obiektem tworzonym przez polecenie CREATE,+
,może być tworzony na perspektywach,+
366,Wyzwalcz INSTEAD OF - (0)
,działa identycznie jak wyzwalacz tybu BEFORE,
,"może być stworzony, any umożliwić wykonanie instrukcji DML na perspektywie",+
,Jest obiektem tworzonym przez polecenie CREATE,+
,może być tworzony na perspektywach,+
367,"Problem niepowtarzalnego odczytu polega na tym, że: - (0)"
,"Użytkownik może odczytać dane zmienione przez innego użytkownika, które nie zostały zatwierdzone przez COMMIT",
,W dwóch różnych transakcjach tego samego użytkownika odczyt tego samego pola daje różne wyniki,
,W dwóch równolegle działających tranzakcjach odczyt tego samego pola daje różne wyniki,
,W dwóch punktach w czasie trwania tej samej transakcji odczy tego samego pola daje różne wyniki,+
należy wszystkie związki jednoznaczne zastąpić związkami jednojednoznacznymi,
0
nic nie zwróci,
pobrania zawartości rekordu ze źródła danych i przejścia do następnego rekordu,
pobrania zawartości rekordu ze źródła danych i przejścia do następnego rekordu,
"zostanie stworzona tabela Osoby, której kluczem głównym będzie pole imie"
zawsze tyle jaka jest liczebność relacji R,
"SELECT job, AVG(sal) FROM emp HAVING AVG (sal) >= 3000 GROUP BY job"
"SELECT job, AVG(sal) FROM emp GROUP BY job WHERE AVG (sal) >= 3000",
"SELECT job, AVG(sal) FROM emp GROUP BY job HAVING AVG (sal) >= 3000",
obszar roboczy używany do wykonania instrukcji SQL,
obszar roboczy używany do wykonania instrukcji SQL,
"SELECT deptno, AVG(sal) FROM emp GROUP BY deptno WHERE COUNT (*) > 3;",
instrukcja CREATE TABLE
czasem,
zawsze,
czasem,
przyznawanie uprawnień do wykonywania operacji na obiektach,
odwołanie do zmiennej typu CHAR w klauzuli WHERE
